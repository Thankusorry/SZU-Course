1. 动态查找表**插入、删除效率高**

2. 静态查找和动态查找**逻辑结构相同**，都是集合，但查找性能不同

3. 顺序查找适合于存储结构为(**顺序表或线性链表**)的线性表

4. 除了时间复杂度为，还常用**平均查找长度**来衡量查找算法的事件性能。

5. 对长度为n的有序单链表，若查找每个元素的概率相等，则**顺序查找表**中任一元素的查找成功的平均查找长度为**(n+1)/2**

6. 二分查找表**必须有序，且表只能以顺序方式存储**

7. 在一个有序表(13,18,24,35,47,50,62,83,90,115,134)，当折半查找值为90的元素时，查找成功的**比较次数为(2)**

8. 折半查找过程对应的判定树是一棵(B)。 
   A.最小生成树 **B.平衡二叉树** C.完全二叉树 D.满二叉树 

9. 一个有序表A含有22个元素，且元素下标从1开始，按折半查找查找A[16]，**需要比较 5 次**

10. 对于长度为1023的顺序存储的有序表，若采用折半查找，在等概率情况下的平均查找长度为 (取整）
  **记住公式：ASL= 深度数*节点数求和 / n **
  $$
  \frac{n+1}{n}\log_{2}{(n+1)}-1
  $$

11. ！！！查找不成功对应的是判定树的**空节点查找次数/n**

12. 设顺序存储的某线性表共有123个元素，按**<font color='CornflowerBlue'>分块查找</font>**的要求等分为3块。若索引表和块内均采用顺序查找，则在等概率情况下，分块查找成功的平均查找长度为()
   **（3+41)/2 +1 =23**

13. 分块查找:**数据分成若干块，每块内数据不必有序，但块间必须有序，每块内最大(或最小）的数据组成索引块**
   **分块查找最佳查找方式是索引块折半查找，块内顺序查找**

14. 假设二叉查找树上的值为1~1000，如果在这棵二叉查找树上查找363，不可能的搜索序列
   **(C.(925,202,911,240,912,245,363))**

   **技巧：右子树->后面所有都比它大，左子树->后面所有都比它小**

15. 任何一棵非空二叉排序树，删除一个结点后再插入，所得到的二叉排序树与原二叉排序树相同。**该说法错误**
   <font color='red'>**只有删除节点是叶子节点才正确**</font>

16. 有关键字集合{53，30，37，12，45，24，96}，从空树开始逐个插入关键字构造一棵二叉排序树。若希望高度最小，则应选择()序列插入
   **中位数先插入，后面从中位数往左右插**

   **<font color='red'>37</font>**，24，12，30，53，45，96

17. <font color='red'>**三个数据A、B、C，A>B>C，能构成5种形态不同的二叉排序树**</font>

18. 在含有n个结点的二叉排序树中查找一个关键字，进行关键字比较的次数最大值是          **n** 

19. 一棵二叉排序树是由关键字序列（18，43，27，44，36，39，77）构成的，其中序遍历序列是  空1 _____ 。

   **18 27 36 39 43 44 77——<font color='red'>中序遍历得到递增序列</font>**

20. 







