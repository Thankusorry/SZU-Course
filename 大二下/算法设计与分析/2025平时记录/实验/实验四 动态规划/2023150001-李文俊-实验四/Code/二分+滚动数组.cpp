/*
 * 动态规划解决鸡蛋掉落问题（带二分查找优化）
 * 参数：
 *   K - 鸡蛋数量
 *   N - 楼层数
 * 返回值：
 *   最坏情况下确定临界楼层所需的最少尝试次数
 */
int erfendp_gd(int K, int N)
{
    // 滚动数组：
    // pre[i] - 表示i层楼、k-1个鸡蛋时的最坏情况尝试次数
    // cur[f] - 表示f层楼、k个鸡蛋时的最坏情况尝试次数
    int pre[N + 1], cur[N + 1];

    // 初始化边界条件：
    // 当楼层为0时不需要尝试（0次）
    // 当楼层为i时，若只有1个鸡蛋则必须线性扫描i次
    for (int i = 0; i <= N; i++) // 注意这里是i<=N，原代码有数组越界风险
    {
        pre[i] = i; // 初始化为最坏情况（线性扫描）
    }

    // 主循环：从2个鸡蛋开始逐步计算到K个鸡蛋的情况
    for (int e = 2; e <= K; ++e) // 当前鸡蛋数量e（外层循环）
    {
        cur[0] = 0; // 0层楼无需尝试

        // 计算当前鸡蛋数e下，从1层到N层的最优解
        for (int f = 1; f <= N; ++f) // 当前楼层数f（内层循环）
        {
            cur[f] = INT_MAX; // 初始化当前状态为极大值

            // 使用二分查找优化尝试楼层的选择
            int l = 1, r = f, res = f; // [l,r]搜索区间，res记录最小尝试次数
            while (l <= r)
            {
                int k = (l + r) / 2;                    // 尝试在第k层扔鸡蛋
                int broken = pre[k - 1];                // 鸡蛋破碎时的最坏情况（e-1个鸡蛋，k-1层楼）
                int notBroken = cur[f - k];             // 鸡蛋没碎时的最坏情况（e个鸡蛋，f-k层楼）
                int worst = max(broken, notBroken) + 1; // 当前尝试的最坏情况次数

                // 更新最小尝试次数
                res = min(res, worst);

                // 根据比较结果调整搜索范围
                if (broken < notBroken) // 当前k值偏小，需要增大
                {
                    l = k + 1;
                }
                else // 当前k值偏大，需要减小
                {
                    r = k - 1;
                }
            }
            cur[f] = res; // 记录当前楼层的最优解
        }

        // 滚动数组更新：将当前状态cur[]复制到pre[]供下一轮使用
        // 注意：原代码中循环条件i<N会导致最后一个元素未更新
        for (int i = 0; i <= N; i++) // 修正为i<=N
        {
            pre[i] = cur[i];
        }
    }

    // 返回最终结果：K个鸡蛋N层楼的最小尝试次数
    return pre[N]; // 原代码返回cur[N]是错误的，应该是pre[N]
}
