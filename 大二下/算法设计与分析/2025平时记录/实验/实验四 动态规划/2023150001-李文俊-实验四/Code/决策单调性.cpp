// 函数juece：使用决策单调性解决鸡蛋掉落问题
// 参数：
//   K - 鸡蛋的数量
//   N - 楼层的总数
// 返回值：
//   返回在最坏情况下，找到临界楼层所需的最少尝试次数
int juece(int K, int N)
{
    // 定义两个一维数组，用于动态规划的状态转移
    // pre[i] 表示i层楼、k-1个鸡蛋时的最坏情况尝试次数
    // cur[f] 表示f层楼、k个鸡蛋时的最坏情况尝试次数
    int pre[N + 1], cur[N + 1];

    // 初始化边界条件：
    // 当楼层为0时，不需要尝试（0次）
    // 当楼层为i时，如果只有1个鸡蛋，则必须从下往上逐层尝试，共i次
    for (int i = 0; i < N; i++)
    {
        pre[i] = i; // 初始化pre数组，假设只有1个鸡蛋的情况
    }

    // 主循环：从2个鸡蛋开始，逐步增加鸡蛋数量直到K个
    for (int e = 2; e <= K; ++e) // 当前考虑的鸡蛋数量e
    {
        cur[0] = 0; // 如果楼层数为0，则不需要尝试（0次）
        int x = 1;  // x表示当前考虑的尝试楼层

        // 对于每一个楼层数n，从1到N，计算最坏情况下的最少尝试次数
        for (int n = 1; n <= N; ++n)
        {
            cur[n] = INT_MAX; // 初始化当前状态为极大值，便于后续取最小值

            // 使用一种优化的方法来确定最优的尝试楼层x
            // 这里通过维护一个变量x，并通过比较来更新它，以找到最优决策点
            while (x < n && max(pre[x - 1], cur[n - x]) > max(pre[x], cur[n - x - 1]))
            {
                x++;
            }

            // 状态转移方程：
            // 在第x层扔下鸡蛋，如果碎了，则在下面的x-1层楼中继续测试，使用e-1个鸡蛋
            // 如果没碎，则在上面的n-x层楼中继续测试，使用e个鸡蛋
            // 最坏情况是这两种情况中的较大者，再加上当前这一次尝试
            cur[n] = 1 + max(pre[x - 1], cur[n - x]);
        }

        // 滚动数组更新：将当前状态cur[]的值复制到pre[]中，供下一轮循环使用
        // 注意：这里应该将cur数组的值赋给pre数组，但原代码中存在数组越界的风险
        // 因此，在实际应用中需要确保数组的大小足够且索引正确
        for (int i = 0; i < N; i++)
        {
            pre[i] = cur[i];
        }
    }

    // 返回最终结果：K个鸡蛋N层楼的最小尝试次数
    return pre[N];
}
