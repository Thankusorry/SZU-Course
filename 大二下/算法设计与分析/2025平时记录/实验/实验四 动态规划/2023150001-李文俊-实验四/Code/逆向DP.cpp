// 函数nsdp：使用动态规划解决鸡蛋掉落问题
// 该函数计算在最坏情况下，确定临界楼层所需的最少尝试次数
// 参数：
//   K - 鸡蛋的数量
//   N - 楼层的总数
// 返回值：
//   返回最坏情况下确定临界楼层所需的最少尝试次数
int nsdp(int K, int N)
{
    // 初始化时间计数器t为0，用于记录尝试次数
    int t = 0;
    // 动态规划表f，f[i][j]表示i个鸡蛋在j层楼中确定临界楼层所需的最少尝试次数
    int **f = new int *[K + 1];
    // 分配内存给动态规划表
    for (int i = 0; i <= K; ++i)
    {
        f[i] = new int[N + 1]();
    }
    // 当f[K][t]小于总楼层数N时，继续增加尝试次数
    while (f[K][t] < N)
    {
        t++; // 增加尝试次数
        // 对于每一个鸡蛋数量i，计算在t次尝试下能覆盖的最大楼层数
        for (int i = 1; i <= K; i++)
            // 状态转移方程：f[i][t] = f[i-1][t-1] + f[i][t-1] + 1
            // f[i-1][t-1]表示鸡蛋在第t层碎了，需要在下面的t-1层楼中继续测试，使用i-1个鸡蛋
            // f[i][t-1]表示鸡蛋在第t层没碎，需要在上面的t-1层楼中继续测试，使用i个鸡蛋
            // 加上当前这一次尝试，所以总楼层数加1
            f[i][t] = f[i - 1][t - 1] + f[i][t - 1] + 1;
    }
    // 使用完后释放动态规划表的内存
    for (int i = 0; i <= K; ++i)
    {
        delete[] f[i]; // 释放每一行的内存
    }
    delete[] f; // 释放动态规划表的内存
    // 返回最坏情况下确定临界楼层所需的最少尝试次数
    return t;
}
