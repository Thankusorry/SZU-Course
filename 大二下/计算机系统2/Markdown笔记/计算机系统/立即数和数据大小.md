**根据立即数大小可以确定指令后缀 bwlq**

| 后缀​ | ​数据宽度​ | ​立即数范围​         | ​典型寄存器​     |
|-----|--------|-----------------|-------------|
| b   | 8-bit  | -128 ～ +127     | AL, BL...   |
| w   | 16-bit | -32768 ～ +32767 | AX, BX...   |
| l   | 32-bit | -2³¹ ～ 2³¹-1    | EAX, EBX... |
| q   | 64-bit | -2⁶³ ～ 2⁶³-1    | RAX, RBX... |

`movb $-17,(%rsp)`
**如果以内存为目的：看操作数大小**
**如果以寄存器为目的：看寄存器**

## movabq

**==movq限制：只能表示为32位补码的立即数作为源操作数，然后符号拓展为64位==**
**`movabsq` 是唯一支持64位立即数的指令**，但仅支持 **寄存器目标操作数**
`movabsq $0x123456789ABCDEF0, %rax` : **将64位立即数直接加载到rax**
**==movabsq不支持直接写入内存==**
因此，如果要将一个64位立即数写入内存，必须经过寄存器作为中间值
	等价于内存到内存
```c
movabsq $0x123456789ABCDEF0, %rax  ; 1. 加载到寄存器
movq %rax, -12(%rbp)               ; 2. 写入内存
```
