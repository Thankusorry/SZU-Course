## 第二章
1. **^** 可以用来交换两个数 `a=a^b` `b=a^b` `a=a^b`
2. **移位运算**是从左向右结合 `x<<j<<k` 等价于 `(x<<j)<<k`
3. **无符号数和补码相互转换**，注意正数时可以共同表示(编码一致)
4. **溢出判断**：无符号数变小，有符号数变号
5. **乘法运算**： `x*y =ux*uy`等价于位模式相同的两个二进制数运算 `~y=-y-1` 
6. 有符号数除法：**加上偏移量** $2^k-1$
	e.g. 情况是在 `sarl $Imm` 前先使用**leaq加载一个常数**
7. 浮点数和整数转换： int 最大值 2^{32}-1 , Float 最大值 2^{128}
int 最大值： 2147483647 最小值：-2147483648
## 第三章  
1. **浮点数也有后缀 float-s double-l**
	double的后缀和int相同，double precision | double word
2. **objdump 对.o文件和.s文件反汇编的结果不同**:[[反汇编器objdump]]
3. **通用寄存器表示不同数据大小bwlq的格式**
	[[掌握整数寄存器]]
4. **寻址：操作数是通过$Imm给出，而Imm表示直接寻址（Imm看作地址）**
5. **操作数限制：**
	**移位操作**：移位次数仅支持1或%cl寄存器 
	**栈操作**：`PUSH` 可接受立即数,`POP`不允许
	**条件设置指令**：目的操作数必须是 ​**8位寄存器或1字节内存**
6. 牢记后缀[[立即数和数据大小]]
7. **任何为==寄存器==生成32位值的指令都会把寄存器的高32位置零**
	不适用于内存
8. **访问内存也需要使用对应大小的寄存器**——64位 (%rax) √ (%eax) ×
9. **cltq：特别常见的情景是前面参数都是int之类的
   ——意味着高32位一直被置零**
	**==后面使用leaq时，必须要用cltq 符号拓展，不然负数可能就会出错==**
	**==必须使用cltq：==**
	1. 当 32 位有符号数（如数组索引 `i`）用于 **64 位地址计算**时
	2. 如果函数返回 `int`（32 位有符号数），但调用者期望接收 64 位值（如 `long`）
10. **函数传递引用类型 `int fun(int &sum)` 本质上传的是指针，所以需要使用(%rdi)来访问**
11. ==**特殊的算术操作**==： 64位乘法和除法
	分为有符号数 `imulq or idivq`和无符号数`mulq or divq` 
	最重要的还是记忆存放位置（==**限制参数**==）： **乘法的结果高64位 %rdx 低64位 %rax**
		**除法恰好相反，高64位存余数，低64位存商**
	引入新的符号拓展指令 cqto ： 
	**和cltq单纯符号扩展不同，cqto扩展的部分是从%rax到%rdx** `%rdx:%rax`
	到底什么时候才用？
		**返回值是long时用简单的imul**
### **控制**
1. 一般只有三种类型会改变条件码：算术，逻辑，CMP/TEST，**mov指令一般不会改变条件码**
	**了解条件码的判断本质：**
		CF：Carry Flag 进位，表示无符号溢出，判断本质 (unsigned)t < (unsigned)u
		SF： Signed Flag 负数表示， t<0
		ZF: Zero Flag 零标志 `t==0`
		OF: Overflow Flag 符号数溢出标志--结果异号
2. 编写汇编代码，开头有分配栈帧 `subq`，结尾记得回收 `addq`‘
3. 访问条件码的后缀：
	- **e = equal   等于/零**
		- **==e / ne 有符号和无符号都匹配==**
	- **n = not      非**
	- **s = sign     负数**
	- **g = greater 大于**
	- **l = less      小于**
	**==无符号数==**
	- **a = above   超过**
	- **b = below   低于**
4. set指令以一个低位寄存器为目的，常见的是 `sets %al`，==**结果是0/1**==
5. **jmp指令：一般 jmp xxx 本质上是基于PC相对寻址**
	**==地址计算方式： 下一行地址+偏移量==**
	链接前是偏移量，链接后被替换成具体地址，但本质还是相对寻址
### Switch语句
跳转表标号： 
1. **跳转到默认情况，说明分支中缺少对应的标号**
2. **都有分支，且分支相同，才算有相同的标号**
3. 汇编代码经过优化后可能省略了C代码中初始化部分
   比如函数返回val，汇编中可能默认返回参数——**函数不能返回一个未定义的变量**
### 过程
**堆栈的三个作用**：
**完整流程：**
1. 当前函数有自己的栈帧，分别用来**保存寄存器，存储局部变量和其他**
2. 函数调用其他函数，首先会存入参数，前六个参数存在寄存器中，后面的参数从右往左存入栈中，最后才压入返回地址，因此新函数开始时(%rsp)表示返回地址
3. 新函数也是保存寄存器，存储局部变量和其他用途

**细节：** 
1. **函数参数按照8字节对齐，但局部变量只需要类型大小对齐**
2. **当局部变量使用了&运算符**，必须在栈中存储，为它分配一个地址
3. **==填call后面的地址或者填指令的地址, 要注意小端法==**
### **数组**
一般数组访问形式：
1. E[i]=`*(E+i)` ，访问值对应指令为 `movT E(%rdi,T),%rax`
2. &E[i]=`E+i` ,访问地址，指令为 `leaq E(%rdi,T),%rax`
C语言表示E+i，实际内存访问的是 `T*i`

**嵌套数组表示形式：`A[i][j]= *(A+i)+j`  内存表示：`A+ T*(i*M+j)` 可以得到列数**

### **结构体**
**结构体尾部对齐是按照结构体内部最大类型来对齐！！！**

做题中易错的点：
1. **对数据大小敏感**：l对应int,q对应long,特别是返回类型 long,还有函数参数
   q-long  l-int w-short b-char ，根据类型可能需要符号拓展再使用
2. **对于内存访问**： 如果是(%rsi)，表示参数是一个指针，如果是Imm(%rsi)，说明参数可能是一个结构体

**union的特性：共用一块内存，同一时间只能存储并访问其中的一个成员**

**有意思的题目：练习3.26**
## 第六章
### 存储技术
1. **SRAM和DRAM区别**
2. **磁盘组成**：盘片 -- 盘面 -- 磁道(柱面) -- 扇区(通常512B) ——计算容量
3. **磁盘时延计算**：**寻道时间+旋转时间+数据传输时间**
   寻道时间：移动到目标扇区的磁道上 = 3~9ms——题目给出
   旋转时间：某时刻到达目的磁道后，磁盘旋转到目的扇区的时间
   平均旋转时间=1/RPM×60/2 最大旋转时间=1/RPM×60
   数据传输时间 = 旋转一个扇区的时间 = 1/RPM×60 / 平均扇区数
4. **系统总线--内存总线--I/O总线**
   读取内存到寄存器：CPU --系统总线--I/O桥 --内存总线 -- DRAM
   **读取磁盘：磁盘属于外存(I/O设备)**
5. 闪存组成和特点
   **每一个块有很多页，起始都是为1，写入以页为单位，将1修改为0**
   **特性**：修改要将整个快擦除 ，并且擦除有最大次数(使用寿命)
6. **时间局部性**：最近被访问的数据或者指令在未来可能会再次被访问
   **空间局部性**：当前访问地址附近的数据在未来可能会再次被访问
   ==**数组只能体现空间局部性，无时间局部性**==
7. ==**注意单位差距： DRAM和SRAM是1024，磁盘是1000**==
8. 存储层次结构：
   **==中心思想：速度更快、容量更小的存储设备作为速度更慢、容量更大的存储设备的缓存==**
   易错判断题： 增加额外一级存储，数据存取的延时一定不会增加
   **缓存不命中时，需要增加一层的查找开销**
9. ==**缓存的速度是主存速度的6倍**==
   Cache命中率：命中次数 / 访问次数
   CPU访问内存的平均时间计算：命中率 × t/6 + 不命中率 × t 
10. ==**地址从0开始，Address0，Cache0**==
11. C = B × **块数**= B × S × E
12. 注意题目对于字大小的解读：一般来说字就是1B，看题目
    同时还有地址位数 -> 内存容量决定
13. 直接映射 -- 全相连映射 -- 多路组相连映射 各自特点
    **直接映射**：每个主存块映射到Cache的固定行
    方式简单，命中率低，效率较低，容易**冲突不命中**
    **全相连映射**：每个主存块映射到Cache的任一行
    方式灵活，命中率较高，标志位多，成本较高
    **多路组相连**：每个主存块映射到Cache固定组中任一行
    命中率较高同时成本较低
    ==**全相联映射需要进行更多的标记位比较，硬件实现更复杂**==
14. **写操作：相当于更新**
    写命中：表示数据在Cache中
	    写穿透：更新Cache后立即更新主存
	    写回：更新Cache后等到数据要丢掉了再更新到主存
	写不命中：表示数据在内存中
		写分配：写到Cache后，更新Cache
		写不分配：只更新主存
	==**记忆搭配：==**
	**==最新的数据在主存——写穿透+写不分配==**
	**==最新的数据在Cache——写回+写分配（主流）**==
15. Cache命中率因素：
    Cache容量大小：容量越大越好
    Cache块大小：块太小，命中率低；块太多，缺失损失大；平衡之下64B最佳
    ==**Cache组大小(S)：较大的组能降低由于冲突不命中出现抖动的可能性**==
    Cache组织：多路组相连平衡利用率和成本
16. **判断缓存是否命中从地址角度分析映射关系**
    ==**遇到写回时写入操作也会占用Cache**==
    直接映射遇到容量增加，映射关系会改变，列数增加
    关键影响是针对于已被缓存的元素，如果是常规按行访问，没有影响
    **但如果是按列访问，新一轮访问时将全部命中！**

## 第七章
1. **C代码到可执行目标文件的四个步骤：**
   cpp,cc1,as,ld
   cpp:.c文件经过预处理器加入#include和#define代码，形成.i文件，还是文本文件
   cc1:编译器将.i文件翻译为汇编代码，生成.s文件(文本)
   as:编译器将汇编代码翻译为机器代码，生成.o,可重定位目标文件——二进制文件
   ld：链接器将不同.o链接在一起，形成可执行目标文件(.exe)——二进制文件
2. **ELF文件定义，格式**
3. ==**局部变量不是符号！**==
4. **强符号和弱符号牢记规则**
   只要是同名就是多重定义
   强符号只能定义一次，多次定义报错ERR
   强符号和弱符号选择强符号
   多个弱符号由链接器随机选择
5. **静态库在gcc命令行中无需明显指定C标准库libc.a(默认库)**
6. **自行创建静态库指令：ar rcs mylib.a myproc1.o myproc2.o**
   链接时需要显式指出：==**gcc –static –o myproc**== main.o **./mylib.a**
7. **符号解析引用关系！**
   E：组成可执行文件的所有目标文件集合
   **当扫描结束，任何不在集合E中的目标文件都将被丢弃**
   U：未解析的引用符号的集合
   **E根据U是否有当前扫到的符号才加入D，否则不会加入，因此符号解析顺序很重要**
   **扫描结束，如果U还有符号，报错！**
   D 当前所有定义符号的集合 
8. .o文件链接是全盘链接，只需扫描一次可以得到全部符号加入D，所以只需要显式链接一次
   对于静态库.a文件，它是按需提取，如果没有U需要的，其他全部丢掉，所以需要多次显示链接
9. **最短命令行直接 gcc** 后面符号引用关系  gcc p.o libx.a
10. 函数定义不需要重定位，调用函数才需要
11. 一个变量变为静态变量，意味着符号类型变为局部变量，仅本文件能看见

   
   