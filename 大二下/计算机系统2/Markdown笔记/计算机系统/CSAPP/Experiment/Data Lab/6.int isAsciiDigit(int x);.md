## 目的：
如果x是ascii码中的0~9，返回1;否则返回0

## 思路1：

**1.** 0-9就是0x30 <= x <= 0x39，先确定高四位是0011，**第一个判断条件 (x&0xf0)^0x30**

**2.** 低四位通过观察得到 不能出现 1x1x和11xx，得到**第二个判断条件**

**!((x&0xa)^0xa) 和 !((x&0xc)^0xc)**

  **3.** 最后高24位的0需要全为0，因此**得到第三个判断条件 (x>>8)^0**

  **4. 将这几个条件按逻辑结合在一起，减少操作数**

**int isAsciiDigit(int x) {**
  **return !( ((x&0xf0)^0x30) | !(x&0xA)^0xA | (x>>8)^0 | !(x&0xc)^0xc);**
**}**
## 思路2：
将问题转换为 x-0x30>=0 & 0x39-x>=0 
```c
int isAsciiDigit(int x) {
  int sign = 0x1<<31;
  int upperBound = sign&(0x39+(~x+1))>>31;
  int lowerBound = sign&(x+(~0x30+1))>>31;
  return !(upperBound|lowerBound);
}
```
**==位级操作的强大==**

**为什么不需要考虑溢出呢：
因为有两个条件同时限制，即使x-0x30溢出，右边也不会同时满足。**