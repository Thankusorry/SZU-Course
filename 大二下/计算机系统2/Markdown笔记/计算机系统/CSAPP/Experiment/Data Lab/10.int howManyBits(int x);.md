## 目的：
返回将X表示为补码所需的最小有效位数

## 思路：

==**1. 这个题目最关键的地方在于如果处理正数和负数==，如果是正数，需要找到它的最高位为1位置，然后加上符号位，如果是负数，在于找到最高位为1的位置，不需要加上符号位，**

**==这是一个误区==，如果这样想，问题就会变得很复杂，实际上正数和负数是统一的，对于负数来说，需要找到最高位为0的位置，然后加上符号位(比如-5(1011))，这样正数和负数本质上就相同**

**因此，<font color="#ff0000">可以把负数，转换为正数</font>，将问题转换为找到最高位为1的位置**

==**2.怎么找？==顺序找需要>> , & , + ，三个运算符*30已经超过最大操作符数，可以巧妙的采用二分法：**

**因为现在我们只需要找到最高的1：**

**如果高16位有（不全为0），那就只需要看高16位，result+=16，将高16位移到低16位，然后看高8位，这样不断往下走到第一位**

**如果高16位没有：那就不需要移位，只看低16位**

**无论有还是没有，都只需要看低16位。**

**==3.特殊情况==：0和-1都只需要1位，0可以通过二分结果为0 +1=1，而-1 符号位和数值位重叠，它的位级表示就是 1，在负数转成正数时变成了 ~1** **à 0，因此，-1和0其实相同。**


**int howManyBits(int x) {
	int b16,b8,b4,b2,b1,b0,N;
	int sign=x>>31;
	x=(sign&~x)|(~sign&x);
	b16=!!(x>>16)<<4;
	x=x>>b16;
	b8=!!(x>>8)<<3;
	x=x>>b8;
	b4=!!(x>>4)<<2;
	x=x>>b4;
	b2=!!(x>>2)<<1;
	x=x>>b2;
	b1=!!(x>>1);
	x=x>>b1;
	b0=x&0x1; // 实际上可以不用加，因为如果转换为正数的话，只有0/1
	return b0+b1+b2+b4+b8+b16+1;
}**