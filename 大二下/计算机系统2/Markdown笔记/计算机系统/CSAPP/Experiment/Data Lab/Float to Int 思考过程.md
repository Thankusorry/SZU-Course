``` c

int floatFloat2Int(unsigned uf) {
	int E;unsigned M;
	unsigned sign=uf>>31;
	unsigned exp=(uf>>23)&0xff;
	unsigned frac=(uf<<9)>>9;
	if(exp==0xff) return 0x80000000;
	if
	M=exp ? (0x800000|frac) : frac;
	E= exp ? (exp-127) :-126;
	
	if(E<0) return 0;
	if(E>31) return 0x80000000;
	if (E>23) M=M<<(E-23);
	else M=M>>(23-E);
	
	if(sign){
		
	}
}

```

**目标：将单精度浮点数的位表示转换为对应的整数的位表示 相当于(int)f**
**规格化:**
E=exp-127
M=1.frac;
~~**非规格化：**~~
~~E=-126 ——int~~ 
~~M=frac;——unsigned 符号位单独剥离出来~~
**实际上不需要区分规格化和非规格化，因为非规格化（用来表示很小的数），不是用来表示整数的**
得到E和M，然后M按照E移位
注意：对于int，除去符号位和隐含位，M只有30位，E不能大于30和小于0(小数)
因为分离frac时已经右移23位，**现在M有24位 M=00000000 1M** 
因此要对E是否>23**分类讨论** ——最多左移(30-23=7)，所以M不能超过01111111（Tmax),所以最后不需要再根据符号位判断是否溢出
最后unsigned 转换为 int 对应结果，此时M是无符号整数，通过移位得到除符号位的右边
	~~对于正数：最大为01111，如果M>0x011111111，则溢出~~
	~~对于负数，最大为10000，如果M>0x80000000,溢出~~ 
**问题：M是包含符号位还是剥离符号位呢？**
	frac是剥离符号位的，M应该也是剥离符号位

**==太多细节辣！==**
