**关键作用：**
1. 分离编译，实现==**模块化设计**==——小模块编译后重新链接到应用
2. ==**高效率**==：不仅是分开编译，更是 共享库的概念，直接调用共享库，而不需要包含整个共享库的代码

# 编译器驱动程序
一步到位的系统（gcc） 称为 **complier driver** [第一章复习]
`gcc -o prog main.c sum.c`
实际上底层调用了 **预处理器-编译器-汇编器-链接器**的四个阶段
`cpp  -o main.i main.c `
`cc1 -o main.s main.i`
`as -o main.o main.s`
`ld -o main main.o sum.o`

![[IMG_0296.jpeg]]
# 静态链接

**可重定位目标文件(.o)** +**静态链接器** =**可执行目标文件** 

**==静态链接器的两个步骤==**
## 1.符号解析 Symbol resolution
==**目的：确定符号引用关联的符号定义**==
![[符号解析.png|525]]
**符号定义**：函数体实现 and 变量声明/初始化
**符号引用**：函数被调用 and 变量被使用或赋值
>[!warning]+ **局部变量不是符号**
> 符号是函数 or 全局变量 or 静态变量 ，==**局部变量不是符号**==
> - 局部变量分配在栈中，不会在过程外被引用，因此不是符号定义

>[!danger]+ **区分static和extern**
> - **extern**表示引用一个外部全局变量，因此它属于**符号引用**
> - **static**表示声明一个静态全局变量，因此属于**符号定义**

==**编译器**==：将定义的符号存放在一个==**符号表**==（symbol table）中
- 符号表是一个结构数组
- 每个表项包含符号名、长度和位置等信息
- **地址状态**：
    - **符号定义**：地址是相对本文件开头的**偏移量**（如 `jmp .L3` ）
    - **符号引用**：地址是**临时占位值**（通常是 `0x0`）
==**链接器**==：**符号解析**——将每个**符号引用都与一个确定的符号定义建立关联**
## 2.重定位
编译器和汇编器生成的是 ==**地址0开始的代码和数据节**==
**链接器 将 符号定义 和 一个内存位置 关联 重定位这些节**

**重定位流程：**
1. ==**合并**==相关.o文件——合并相同section
2. ==**确定**==每个标号的==**地址**==
	**地址确定原理：**
	链接器决定==**每个段的起始虚拟地址**==**（如 .text 从 0x400000 开始）**
	按顺序排列每个目标文件的段内容
	符号地址 = 段基址 + 在段内偏移量
3. 在指令中==**修改为重定位后的新地址**==——重定位
	e.g. 查找 printf 的最终地址（如 0x400500）
	计算需要填入的正确值（根据指令类型）
	将地址值写入到目标文件指定位置
```asm
; 重定位前（main.o）
400210: e8 00 00 00 00   call 0x0  (占位符)

; 重定位后（可执行文件）
400210: e8 eb 02 00 00   call 400500 <printf>
```

# 三类目标文件
==**Linux系统使用ELF格式 Executable and Linkable Format**==

**1.可重定位目标文件(.o)**：二进制代码 +数据 ——可和其他可重定位文件合并为可执行文件
- 每个.o 文件由对应的.c文件生成
- 每个.o文件代码和数据**地址都从0开始**
**2.可执行目标文件 (默认为a.out)**：
- 包含的代码和数据**可以被直接复制到内存并被执行**
- 代码和数据地址为**虚拟地址空间中的地址**
**3.共享目标文件(.so)**：特殊的可重定位目标文件
- 在装入或运行时被装入到内存并**自动被链接**，称为共享库文件
## 可重定位目标文件——ELF格式
**整体框架：**
![[整体.png]]
**ELF header**

**.text**
**.rodata**
**.data**
**.bss**
**.symtab**
**.rel.txt**
**.rel.data**

**.dubug**
**.strtab**
**.line**

**Section header** 
### **ELF Header 64B**
**对整个文件的描述**
**Migic 最开始16字节：**
1. **四个字节通过ASCII码标识文件的类型**——'E' 'L' 'F'
2. **一个字节标识ELF文件类型** 0x1-32位 0x2-64位
3. **一个字节标识字节序** 0x1小端法 0x2大端法
4. **一个字节标识版本号**，通常为0x1
5. **最后九个字节填充0**
![[ELF magic.png]]
### .text
编译后的 **==代码部分==**
### .rodata -> .data
.rodata 存放**只读数据(printf字符串)**
**.data 存放==已初始化的全局和静态C变量==**
### **.bss  Better Save Space** 
未初始化的全局和静态变量， 以及==**所有被初始化为0的全局/静态变量**==
<font color="#ff0000">注意：bss section不占据实际空间，只是一个占位符</font>

### 其他section
![[section.png]]
==**.symtab 节**==
- 存放函数和全局变量 （符号表）信息 ，它不包括局部变量

**==.rel.txt和rel.data==** 节中记录了这些被临时填充为0的外部引用位置——将来**重定位时再修改**
==**.rel.text 节**==
- .text节的重定位信息，用于重新修改代码段的指令中的地址信息
==**.rel.data 节**==
- .data节的重定位信息，用于对被模块使用或定义的全局变量进行重定位的信息
==**.debug 节**==
- 调试用符号表 (gcc -g)
==**strtab 节**==
- 包含symtab和debug节中符号及节名
**.line节**
- 调试信息，为程序指令码与源文件的行号建立联系
==**Section header table（节头表）**==
- 每个节的节名、偏移和大小

## 可重定位目标文件
**==链接本质：合并相同的“节” ==** **[sections]**
**代码(.text)  ->  数据(.data)  ->  静态变量(.bss)**
![[Relocatable file.png]]
## 可执行目标文件
