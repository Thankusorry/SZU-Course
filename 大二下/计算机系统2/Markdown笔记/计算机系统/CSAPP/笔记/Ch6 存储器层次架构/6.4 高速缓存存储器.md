**在CPU和Main Memory之间的==SRAM高速缓存==(L1,L2,L3)**
- L1：4个时钟周期
- L2：10个时钟周期
- L3：50个时钟周期
![[SRAM cache.png]]
## **参数**
**缓存块（Cache Line）：数据交换的最小单位**
- 1 Byte是内存块的最小单元 **memory block** 
- 缓存块 **Cache Line** ：主流是64个字节 
**Cache 和 Main Memory 之间交换 最小Line 大小**，内存我可能只需要一个字节，但是缓存的设计会把Line全部加载进来 【内存向大哥Cache靠齐】

## 工作原理
1. **Cache以Line为单位进行操作**
2. 当CPU发出**访内操作**请求后，首先由Cache控制器 **==判断==** 当前请求的字是否在Cache中，若在，命中，否则，不命中
3. **==读 Read==**:
	- 命中：直接对Cache
	- 不命中：**==“装入通过”==：从主存读出所需字送到CPU，且把含该字的==块==送Cache**，若Cache已满，置换算法
4. **==写 Write：==**
	1. **Write Hit**
		- ==**Write through 写穿透**==**：写cache同时写内存【内存数据永远是新的，cache替换时直接丢掉旧的数据】**
		- **==Write back 写回==**：CPU只写cache，不写内存【省事，不用关注内存，只有要替换时再把写到内存】——需要保存数据块是否被修改，line增加修 改位
	2. **Write Miss**
		- **==No-write-allocate 写不分配==**：直接更新Mem
		- **==Write-allocate 写分配==**：将Mem中数据加载到Cache中更新，再写入cache[写cache比写Memory快得多]

==**写不分配和写穿透搭配使用：以Mem为主，最新数据保持在Mem中**==
==**写分配和写回搭配使用：以Cache为主，最新数据保持在Cache中**==
 **现代 CPU 通常采用 ​写分配 + 写回（Write-Back）​ 的组合策略**

**==Cache命中率==**：在一个程序执行期间，设**Nc表示cache完成存取的总次数**，**Nm表示主存完成存取的总次数**，h定义为命中率$h=\frac{N_c}{N_c+N_m}$
**==平均访问时间==**：若tc表示**命中时的Cache访问时间**，tm表示**未命中时的主存访问时间**，1-h表示未命中率，则Cache/主存系统的平均访问时间ta为$ta= h × tc + (1 - h) × tm$
### **练习**
某计算机系统的内存储器由cache和主存构成，**cache的存取周期为45ns**，**主存的存取周期为200n**s。已知在一段给定的时间内，**CPU共访问内存4500次，其中340次访问主存**
   
---
**Cache命中率**=(4500-340)/4500=0.92
**Cpu访问内存的平均时间**=45×0.92+200×0.08=57.4ns
**Cache-主存系统的效率**=45/57.4=78%

# Cache 组织（重点难点）
**==Cache对CPU而言是透明的，即CPU不知道Cache的存在，所以CPU需要的地址都是内存地址==**
**三种映射关系（本质相同）：**
**①直接映射方式**
**②全相联映射**
==**③多路组相联映射（Normal）**==

## **总体架构：General Cache Organization (S, E, B，m)**
“行列”分布：
- **“行” Set ：组**
- **“列” Way：路** E-way associated ，N-way associated
- **B：数据大小**
- **地址位数 m**
![[通用组织架构.png]]
**每个Cache line由三部分组成：**
1. **valid bit 有效位[1 bit]**：判断是否有效
2. **tag 标识位[t bits]**：唯一标识Set中的这一个line
3. **B 数据位[b bits]**：表示存储数据的大小，直接决定一个缓存行能覆盖的地址数量
   **==比如B=2，表示一个Cache Line能存储2字节，<font color="#ff0000">对应</font>两个地址==**
>[!danger]+ danger
> **Cache line里存的不是地址，是数据，地址的作用是映射到Cache line里面的数据**

**==Cache容量：S×E×B==**

### **索引方式**
==**b=log2(B)：索引数据需要的位数**==
==**s=log2(S)：索引行数需要的位数**==
==**t=m-s-b**== 

根据**s定位行** ---> **t比较tag,如果一样才会继续去找**，然后**靠b索引数据的起始地址**
![[cache index.png]]

>[!help]+ 为什么行索引在中间
>**行索引在最前面**——连续的内存块被映射到相同的Cache Line，**空间局部性很差**

### **查找过程**
#### **1.组选择 Set Selection**
**根据s决定Set s**
![[Set Selection.png]]
#### **2.行匹配 Line matching**
**Valid bit=1 & tag match == hit**
![[行匹配.png|600]]

#### **3.字抽取 word extraction**
**根据b决定读取数据的起始地址**
![[字抽取.png]]

## 直接映射高速缓存 Direct Mapped Cache
<font color="#ff0000">E = 1</font>
**==内存到Set映射方式为Round-roubin== 01230123....**
**每个Set只存储一个Cache Line**
**==未命中替换策略：直接替换==**
**利用率低，命中率低，效率较低，容易冲突不命中**
### **例子**
**(S,E,B,m)= (4,1,2,4) ——》s=2,b=1,t=1** **假设地址位数等于4**
>[!REF]+ **总是忘记且混淆的点：地址位数和按字节寻址**
> **地址位数**表示用于表示内存地址的二进制位数（32位地址）
**按字节寻址**：每个地址对应内存中的一个字节

**==B=2——一个Cache Line能存储两个字节，映射两个地址==**
**画出内存图：**
![[不想去名字了.png|450]]
Address trace (reads, one byte per read):
	0	[0000], miss——M[0-1]放入Set 0
	1	[0001], hit
	7	[0111], miss——M[6-7]放入Set 3
	**8	[1000], miss——M[8-9]替换M[0-1]**
	**0	[0000], miss——M[0-1]放入M[8-9]**
**8和0发生交替引用，导致cache line一直不命中——==冲突不命中 conflict miss==**

### **冲突不命中例子**
![[冲突不命中例子.png]]
**理论上，这个程序有良好的空间局部性和时间局部性**
![[内存分布.png]]
#### **实际上：**
**假设有四个Set**
**数组访问x[0]——》将x[0]-x[3]的加载到Set 0**
**哎，数组接着访问y[0] ——》将y[0]-y[3]覆盖x[0]-x[3]**
因此，永远都不会命中(ŎдŎ；)

**把y的起始地址再往后移四个就能解决这个问题**

## 全相连 S=1
**一行表示存储所有Cache Line**
**==容易忘记的：S=1不需要浪费bit来表示,E=C/B,只剩t和b==**
**利用率高，方式灵活（定位时，不需要判断，只需替换），但是标志位较长，需要更多比较电路——成本太高**
![[Set 0.png]]

## 最常用 E路组相连缓存(E>1,S>1)
**E-way Set Associative Cache**

**==替换策略：1.首先选择空行 2.如果没空行，执行替换策略==**
**组内为全相连(任意位置)，组间为直接映射（Set Index 映射），集中了两个方式的优点。成本也不太高**
![[多路组相连.png]]

### **练习1**
设某计算机**主存容量为16MB**，**缓存的容量为16KB**。**每个==字块==有8个字**，==每个字32位==。设计一个**四路**组相联映射（缓存每组内共有4个字块）的缓存组织。请画出主存地址字段中各段的位数

---
M=16MB=$2^{24}B$ ——**m=24**
C=16KB=$2^{14}B$ 
E=4
B=8字×4字节=32B——**b=5**
->S=C/E/B=$2^7$——**s=7**
**t=12**

### 练习2
设**主存容量为256KB**， **缓存的容量为2KB**，**块长为4B**。请画出缓存地址格式，直接映射、全相联、四路组相联方式下的主存地址格式。

M=256KB=$2^{18}B$——m=18
C=$2^{11}B$
B=4B——b=2

**直接映射：E=1 -> S=512-> s=9 -> tag=7 s=9 b=2**
**全相连：   S=1 -> E=512 -> tag=16 b=2**
**四路组相连： E=4 -> S=128 -> s=7 -> tag=9 s=7 b=2**

## **replacement policy 替换策略 ：**
1. **最主流 LRU  Least recently used / LFU Least Frequently user** 最近时间最少被访问（“老古董”）或最近最少被使用，会被踢掉
2. **FIFO (first in first out)** 存活时间最久
3. **RANDOM**
4.  **Round-Robin：轮询替换**：最简单替换，按固定顺序（如循环）逐出缓存行

**LRU示例：访问就提到最前，替换就替换最后**
![[LRU.png|475]]

# Cache 性能

## **提高Cache性能：**
①提高命中率
②缩短缺失后的处理时间
③提高访问Cache的速度

### **提高命中率方法**
#### **1.Cache 容量**
理论上越大越好，实际也有瓶颈
![[Cache capacity v.s hit rate.png|500]]
#### **2.Cache Line大小**
**也就是Memory Block 向 Cache line看齐的64字节**
**为什么是64字节(空间局部性和时间局部性的平衡）：**
- 块太小：命中率将降低
- 块太大：缺失损失更大，需要花费更长的时间来装入数据块
![[Pasted image 20250513120402.png]]
![[cache line 64B.png]]
#### **3.组织方式**
**多路组相联最合适**

#### **4.多级组织**
**主流的L1,L2,L3**
- 采用两级或更多级cache来提高命中率
- **将Cache分解为指令Cache和数据Cache——并行访问不同 Cache，提升吞吐量**
#### **5.替换策略**
**主流 LRU Least Recent Used**

## **Cache Miss种类**：
1. **强制不命中(compulsory miss)/冷不命中(cold miss)** （开机或进程切换）：空缓存，称为冷缓存(cold cache)，**特点是短暂的**，等待缓存warmed up后不会出现
2. **冲突不命中 conflict miss** : 因为被映射到同一个Cache line并且交替引用和替换，导致一直不命中——解决方案：增加Cache容量，增加组数
3. **容量不命中 capacity miss**: **Cache无法装入程序需要访问的所有块**
   e.g. 每次加载 4 个块后，访问第 5 个块时，必须替换掉第 1 个块；当再次访问第 1 个块时，必然发生不命中
Conflict Miss 和 Capacity Miss 本质区别在于Cache总容量区别，冲突不命中更多强调**映射冲突**，容量不命中是 ​**总量不足**


## Intel i7 处理器存储器层次架构
![[intel i7.png]]

### **课堂练习：**
C=32B,**B=8B**

**`int a[8][2];`**
**for(i=0;i<8;i++)**
	**for(j=0;j<2;j++)**
			**sum+=`a[i][j]`**

**求直接映射缓存命中率**

1.先求Cache布局
**==一个B能存储两个int==**
E=1 -> S=4 -> tag= s=2,b=3

a00 miss  -> add a00|a01
a01 hit 
a02 miss -> add a02|a03
a03 hit
**—— 命中率50%**

**关键：**
1. **==B决定一个Cache映射个数==**
2. **映射方式决定命中率（直接映射的Round-roubin方式)**
	- 这个Round-roubin是按Cache line大小来划分的，所以才是0123.. 