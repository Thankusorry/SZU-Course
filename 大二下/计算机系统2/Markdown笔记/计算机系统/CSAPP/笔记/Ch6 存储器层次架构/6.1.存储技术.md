# 1.RAM(Random-Access Memory)
**随机访问存储器**
**==随机==**：可以随机写入和读取数据 a[4]=1;  **只要有地址，就可操作，没有限制**
分为
1. 静态SRAM：高速缓存
2. 动态DRAM：主存

**静态(1MB)比动态(100MB~1000MB)更快，更小，更贵**

## **1.SRAM**
**双稳态特性的存储单元——只要有电就能永远保持数据**
 
## **2.DRAM**
**电容充电——需要不断刷新使电压保持0 1状态**
### **DRAM内部结构**
**DRAM的基本单元是超单元supercell**
![[DRAMsupercell.png]]
**16是supercell的个数，8是每个supercell存储8bit的数据**

**Memory Controller 内存控制器 控制DRAM芯片的读写** 
	行和列共有一个DRAM地址引脚(pin)
	先把行读到内部行缓冲区 （Internal row buffer) ，然后再读缓冲区的列数
	**虽然增加访问时间，但能减少引脚数量**
![[内存控制器.png]]

### **内存模块 Memory Module**
一个DRAM芯片：大小是 8M×8bit=8MB
![[Memory Module.png]]

### **主流：增强版DRAM**
**DDR SDRAM : Double Data-Rate Synchrounous DRAM**
- **预取缓冲区的大小来划分:DDR (2 bits), DDR2 (4 bits), DDR3 (8 bits),DDR4(16 bits)**

## **主要区别**
1. SRAM对干扰不敏感，不需要刷新
   DRAM对干扰非常敏感，受到干扰会使电压扰乱，导致数据永远不会恢复，当漏电时，DRAM单元会在ms内失去电荷，需要ns级别的计算机重新读出数据并重写刷新
**EDC：Error Detection and Correction**
![[DRAM VS SRAM.png]]
**共同特点：DRAM 和SRAM为易失性存储器
==易失性 Votaile== : 电荷会随时间泄漏，断电丢失数据**

## DRAM and CPU
**总线(bus)结构：总线是一组并行的导线，携带数据，地址和控制信号，多个设备共享多条总线**
**CPU[总线接口]** --- <font color="#ff0000">system bus</font> --- **I/O bridge** --- <font color="#ff0000">memory bus</font> --- **Memory**
**读事务**(read transactioin)：内存传数据到CPU
**写事务**(write transactioin)：CPU传数据到内存
![[总线结构.png]]
### 简单的例子
`movq A,%rax` 从内存中读取一个数放到寄存器中

总线接口发起读事务(read transactioin) → CPU将地址放到系统总线，I/O桥将信号传递到内存总线，**主存收到内存总线上的地址信号并且读地址->==信号和数据共享一组导线==**
内存从DRAM中的读取地址，放到内存总线，I/O bridge在传到系统总线，CPU读取数据
![[CSAPP/Image/例子.png]]


# Disk 磁盘
**非易失性存储器 nonvolatile memory**
**分为机械磁盘和固态硬盘**
**从磁盘读数据是ms级别，比DRAM慢10w倍，比SRAM慢100w倍**
## 机械磁盘(旋转磁盘)
![[参数图片.png]]
**16TB​**：硬盘的存储容量单位，1TB=1024GB=1,048,576MB
**256MB**​：硬盘的DRAM缓存容量，本质是数据中转缓冲区
​**7200转：** 主轴电机每分钟旋转次数
​**PMR（垂直磁记录），CMR（传统磁记录）：** **存储技术**，实现不同的存储密度
![[机械磁盘示意图.png]]
![[Pasted image 20250510170635.png]]
![[Pasted image 20250510170652.png]]
### **磁盘构造**
**==Platter 饼-> surfaces  面-> tracks 磁道-> secter扇区->Byte字节数==**
磁盘由 **==盘片(platter)==** 构成，每个盘片有两个==**表面(surface)**==,表面有磁性记录材料
盘片通过中央一个可以旋转的==**主轴(spindle)**== 以一个固定的**旋转速率(rotational rate)** 旋转
这个**速率称为==RPM(Revolution Per Minute)==每分钟转数**
![[platter and surfaces.png]]

Surface又被划分为一组同心圆，称为==**磁道track**==
↓
每个**磁道**又被划分为一组==**有间隙(gap)的扇区sector**==
↓
每次**扇区**包含相同数量的==**数据位(512B)**==
**Gap存放扇区的标识信息，无数据**
![[surface-tracks-sector.png]]

术语：**==柱面cylinder==**：**对齐的磁道形成一个柱面**
下图的k：**六个**到主轴距离相等的**磁道集合**
![[柱面.png]]
### **磁盘容量**
**可存储的最多比特数——逐层计算**
**==Platter 饼-> surfaces  面-> tracks 磁道-> secter扇区->Byte字节数==**
![[磁盘容量.png]]
![[练习6.2.png]]
**注意：**
1. 一个盘面的 **==磁道数也可以用柱面==** 表示
2. **==DRAM和SRAM容量是1024，磁盘和网络等I/O容量是1000==**

`2*2*10000*400*512=8.192GB`

### **磁盘操作**
**==读/写头 read/write head== 负责读写**
**==传动臂  actuator arm==     负责移动**
**所有读写头垂直排列，一致行动——==所有读写头都位于一个柱面上==**
**==寻道seek==：通过传动臂前后移动将读写头定位到指定的磁道**
![[磁盘旋转-1.png]]
**读写头在起飞 ┌╏ º □ º ╏┐吓**

>[!help]+ Q：读写头不触碰磁盘但和磁盘里得非常近，是怎么读写数据的？
>**精密的磁阻传感器**


**磁盘必须在无尘环境下工作（密封包装），一粒灰尘都会引发head crash "坠机"**
## 磁盘访问时间
**==访问时间  =  寻道时间 +  旋转时间 + 数据传输时间==** 
$$
T_{access}=T_{seek}+T_{rotation}+T_{transfer}
$$
**主要由寻道时间和旋转时间组成**
==**寻道时间 Seek Time**==：当前磁道移动到目标磁道时间 3—9 ms 
- 读写头之前的位置
- 传动臂移动速度
==**旋转时间 Rotational latency**==：经过磁盘旋转，目标扇区到达磁头下的时间
- 到达位置
- 盘面转速 RPM 通常7200转/min
  **最大旋转时间：转一圈 `1/RPM×60=8ms`**
  **平均旋转时间：转半圈 4ms**
==**数据传输时间 Transfer Time**==：**旋转一个扇区的时间**  `1/RPM×60/平均扇区数`
$T_{avg-transfer}=T_{max-rotation}/400\approx0.02ms$

### **练习**
**给定条件:**
- 旋转速度 = 7,200 RPM
- 平均寻道时间 = 9 ms.
- 平均扇区数/磁道 = 400.
**计算：**
- **Seek Time**=9ms
- **Rotational latency**= 1/7200×60/2×1000ms=4 ms
- **Transfer Time**= 0.02ms
- **Access Time** = 13.02ms

## 逻辑磁盘块
**操作系统和物理磁盘之间存在着映射关系**

**操作系统**：一组连续扇区被封装成**一个b-sized大小的逻辑盘块**
↓<font color="#ff0000">逻辑块号</font>
**磁盘控制器：维护逻辑块与物理块之间的映射**
↓ <font color="#ff0000">盘片，磁道，扇区三元组</font>
**物理磁盘扇区**
![[逻辑磁盘块.png]]

>[!REF]+ **为什么磁盘格式化后比最大容量要小**
>允许控制器从每个区域中保留一部分空闲柱面，用作特殊情况

### **练习 6.4**
![[6.4.png]]
**1MB=2,048个逻辑块~对应2000个扇区**

**最好情况：块被映射到连续的扇区** 
- 总时间=寻道时间+平均旋转时间+2×最大旋转时间 **20ms**
**随机情况：块被映射到随机扇区**,每次都要寻道+平均旋转
- 总时间=20×（寻道时间+平均旋转时间） **16s**
**==清理磁盘碎片的重要性==**

## 连接I/O设备
**内存总线 -I/O bridge - 系统总线： Main memory and CPU 的连接**
**==I/O总线==**：连接IO设备到CPU和主存
**经典的I/O总线模型：PCI[Peripheral Component Interconnect] 外围设备互联**
![[PCI.jpg]]
- **USB(Universal Serial Bus) 通用串行总线**：各种设备
- **图形适配器**：显示器
- **主机总线适配器**：连接磁盘到I/O总线，使用接口连接，**常听的接口SATA,SCSI,PCIE**
**内存映射I/O**：保留一块地址空间专门用于I/O设备通信

### **读取一个磁盘扇区到内存**
1. CPU通过将**命令（读）、逻辑块号和目的存储器地址**写到与磁盘相关联的存储器映射地址，发起一个磁盘读请求操作
![[6ae649d23423ad1108c3bb84e402ec9.jpg]]
2. 磁盘控制器**读取扇区**，并执行到**主存的DMA传送**
![[6a94b447ee8c8dfab956f114010faf9.jpg|500]]
3. 当DMA传送完成时，磁盘控制器用**中断方式通知CPU** (需要一个特殊引脚与CPU相连)
![[4281a0931fe7656d5fafb99afc2e736.jpg]]
# 固态硬盘 Solid State Disk SSD
![[闪存芯片.png]]
![[基本思想.png]]
**闪存物理特性：块Block ,每个block 有很多页page
==1.数据以页单位读写，且只能把1改为0，不能把0改为1==** 
**写入之前所有存储位都是1，==写入本质==就是将某些存储为从1变成0**
**==擦除本质==就是把所有存储位都变成1**
在闪存里**修改可以基于某一页**，但是**必须先擦除SSD块，才能写入数据**，相当于一栋楼，擦除只能把整栋楼擦掉
**读SSD比写更快 写不仅要擦除，还得缓存不用写的页的数据**
**==2.使用寿命==**：进行大约10,0000次重复写后，块会磨损坏
很多房间，每个房间只能使用10w次，每次用完都要清洗，清洗完再使用，一旦用完了就不能使用了

## FTL机制：
**1.地址映射 mapping** 和磁盘控制器一样，映射CPU看到的房间号和物理的房间号的关系

**2.磨损均衡 wear-leveling ：把压力分摊到其他块，使用寿命**

**3.垃圾回收 garbage collection**