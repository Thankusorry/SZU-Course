
# 3.7 过程——C语言中的函数调用
1） 掌握通用的栈帧结构 
2） 掌握过程调用call  
3） 掌握数据传送   
4） 掌握栈上的局部存储
5） 掌握递归过程  

## 栈帧——媒介
**栈指针%rsp**
==**程序通过栈来分配和管理存储空间**==
![[栈帧示意图 1.png|375]]
## 1. 转移控制——函数调用和返回
**Call指令调用，ret指令返回**
	**直接调用**： `call .L3` 标签 / `call 0x400600`
	**间接调用：**
		`call  *%rcx` 跳转到%rcx所存的内存地址
		`call *(0x400600)` 跳转到地址所存的内存地址
![[call和ret指令一般形式 1.png|600]]
**具体执行 ： P 中调用 Q**
1. **把Q的返回地址(call的下一行地址)压入堆栈**
2. **把%rip替换为Q的起始地址**
![[控制转移例子 1.png|1075]]
## 2. 函数参数——传递参数
**寄存器最多存放六个参数 %rdi %rsi %rdx %rcx %r8 %r9**
	**如果还有多的参数，就需要通过栈存储**

**细节：**
	1. 通过栈传递参数时，==**所有的数据大小都向8的倍数对齐**==
	2. **参数大到小压栈，第七个参数在栈顶，最后保存返回地址**
![[栈帧示意图 1.png|450]]

## 3. 局部变量存储
- **寄存区不足以存放所有本地数据**
- **局部变量使用地址运算符 & 时 必须要为他产生一个地址并且用栈保存**
	- 寄存器不能同时保存一个变量的值和地址，而栈可以提供像指针一样的作用
### 例子1：参数为地址并且局部变量充当函数参数
```c
long call_proc(){
	long x1=1;
	int x2=2;
	short x3=3;
	char x4=4;
	proc(x1,&x1,x2,&x2,x3,&x3,x4,&x4);
	return (x1+x2) * (x3-x4);
}
```

**x1-x4是局部变量并且使用&，因此要用栈为他们分配地址**
>[!note]+ **15字节分配地址**
> **subq $32,%rsp**
> **movq $1,24(%rsp)**
> **movl  $2,20(%rsp)**
> **movw $3,18(%rsp)**
> **movb $4,17(%rsp)**

![[Pasted image 20250420015031.png|455]]

>[!tip]+ **==函数参数和局部变量差别==**
>**函数参数：栈分配需要8字节对齐**
>**局部变量：栈分配只需要字节对齐 bwlq**


## 4. 寄存器的局部存储

**被调用者保存寄存器： %rbx %rbp %r12 %r13 %r14 %r15**
**其他除了%rsp，都是调用者保存**

**和局部存储不同，==寄存器通过push和pop指令保存==**


## 函数调用总结
**函数main 调用 函数Q**

**假设main执行前：栈是空的**

**执行main函数：**
	**正在执行的函数有自己的栈帧**：**保存寄存器**，**局部变量**和一些预留空间

**main调用Q：**
1. 先传递参数：6个参数放入寄存器，多于参数从右到左压入堆栈中
2. 压入返回地址

**执行Q函数：**
	Q也有自己的保存寄存器，局部变量和其他

**Q返回 ret：**
1. 恢复Q执行过程中分配的栈指针
2. 读取返回地址替换到%rip回到main

![[栈帧示意图 1.png|450]]
## 递归过程
1. **==调用函数的结果保存在%rax==**
2. **参数的值会被改变 %rdi,%rsi** 

### **例子：计算n!**
**long rfact(long n){**
    **long result;**
    **if (n <= 1)**
        **result = 1;**
    **else**
        **result = n * rfact(n-1);**
    **return result;**
**}**

**1.先保存用到的寄存器 %rbx**
Rfract:
  pushq %rbx
  ....
  popq %rbx
  ret
**2.中间函数部分**
**movq %rdi, %rdx**  n存储在%rdx
**movl  $1 %eax**     result结束值，不影响后面重新赋值
**comq $1, %rdx**     n : 1 判断
**jle .L35**
**decq %rdi /  leaq -1(%rdi),%rdi**
**call rfract**          返回值 rfract(n-1)在%rax  
**imulq %rbx,%rax**  
	**这就是为什么要保存 n ，调用函数需要n-1**

**.L35**
 **popq %rbx         result=1**
 **ret**


# 3.8 数组分配和访问
1） 掌握数组的分配 
2） 掌握指针运算
3） 掌握嵌套数组

## 数组分配
数组 **T** A[N] 内部实现：
1. 分配 **连续**的 T大小 × N个字节的内存空间
2. **A表示的是指向数组开头的指针**
**-> 数据元素A[i]存放在地址A+L·i的地方**
![[数组示意图.png]]
**==最常用的访问方式：内存引用指令 A (ra,rb,sizeof(T))

## 指针运算
**C语言中 指针p：**
1. `p++`指针移动的距离是T大小的字节
2. `(p+2)-p =2`  指针相减 指的是两个地址之间隔了几个内存单位
3. **操作符&**用于获取变量地址
4. 操作符 * 则用于指针的间接引用——**求值**

**即A[i] = * (A+i) ，A+i= &A[i]**

### **示例：**
**E起始地址存储在%rbx，索引i存储在%rcx**

| 表达式            | 类型    | 值           | 汇编代码                       |
| -------------- | ----- | ----------- | -------------------------- |
| **E**          | int * | Xe          | movq %rbx,%rax             |
| **E[0]**       | int   | M[Xe]       | movl (%rbx),%eax           |
| **E[i]**       | int   | M[Xe+4i]    | movl (%rbx,%rcx,4),%eax    |
| **&E[2]**      | int * | Xe+8        | leaq 8(%rbx),%rax          |
| **E+i-1**      | int * | Xe+4(i-1)   | lead -4(%rbx,%rcx,4)，%rax  |
| **`*(E+i-3)`** | int   | M[Xe+4i-12] | movl -12(%rbx,%rcx,4),%eax |
| **&E[i]-E**    | long  | i           | movq %rcx,%rax             |
|                |       |             |                            |
## 3.嵌套数组
`T A [M] [N]` **"行优先"分配**
**访问规则：起始地址+字节大小×（ i ×列数+ j ）**
-  `&A[i][j]= A+T(N×i+j)`
### 例子1：` A[5][3]`
![[二维数组.png|250]]
**leaq指令做简单运算**--`A[i][j]=A+4(3i+j)=A+12i+4j`
```c
leaq (%rsi,%rsi,2), %rax //compute 3i
leaq (%rdi,%rax,4), %rax //compute XA+12i
movl (%rax,%rdx,4), %eax //read from M[XA+12i+4j]
```

### **练习3.38 通过地址访问判断列数**
![[练习3.38.png]]
**做法：计算数组索引**

1. %rdx= 8%rdi = 8i
2. %rdx= %rdx-%rdi = 7i
3. %rdx=%rdx+%rsi = 7i+j
4. %rax = 5%rsi = 5j
5. %rdi=%rdi+%rax=i+5j

6. **%rax= Q+8%rdi = Q+8(i+5j)——M=5**
7. **%rax = %rax +P+8%rdx=P+8(7i+j)——N=7**

# 3.9 异质的数据结构
1） 掌握结构体(联合体)偏移量和大小 
2） 掌握数据对齐 

## 结构体
结构的实现类似数组，**连续分配对应的内存空间**
**示例：**
**struct rec {**
	**int i;**
	**int j;**
	**int a[2];**
	**int * p;**
**}r;**
![[结构体示意图.png]]
==**画图！**==

## 数据对齐
期末考试有一道大题会考察数据对齐

==**数据对齐原则1：任何K字节的基本对象地址必须是K字节**==
	int 对应的偏移量要和4对齐（要等于4的倍数）

### 例子1
**struct S1 {**
    **int i;**
    **char c;**
    **int j;**
**};**
![[数据对齐.png]]
**未对齐——紧凑布局**
**对齐——对齐布局**

==**数据对齐原则2：结构体尾部按照结构体最大元素对齐**==

### 练习2：
**struct mystruct {**
	**char c;**
	**double* dp;**
	**int i;**
**} m[2];**

**对齐： 1 (char) 7(对齐) 8(double * ) 4 (int) [20B，尾部需要按照8B对齐] + 4B (尾部)**

## Union
**每一个元素都叠在一起，结构体的大小=最大元素大小**
![[Union.png|375]]
![[练习.png]]
str1:**指针(8)+char(1)+对齐(7)+long(8)** = 24B
data： **double 8 * 3 =24B**
	**总大小24B**




# 答疑环节

