## 基本原则
结构的实现类似数组，**连续分配对应的内存空间**
**示例：**
**struct rec {**
	**int i;**
	**int j;**
	**int a[2];**
	**int * p;**
**}r;**
![[结构体示意图.png]]
计算 p= & a[i+j]：XR in %rdi
1. movl 4(%rdi),%eax
2. addl  (%rdi),%eax  // i+j
3. **==cltq==**
4. **leaq** 8(%rdi,%rax,4),%rax // & a[i+j] = a+4(i+j)=%rdi+8+4(i+j)
5. movq %rax, 16(%rdi)
>[!fail]+  **Q:为什么要cltq？一定要cltq吗？**
> **1. 符号扩展的必要性：**
i和j被假定为有符号的32位整数（例如int类型）。当计算i+j时，结果可能为负数。cltq将%eax（32位）符号扩展到%rax（64位），确保在地址计算中使用正确的符号扩展值。若省略cltq，%rax的高32位会被隐式零扩展（而非符号扩展），导致负偏移量被错误解释为大正数，从而访问错误的内存地址。
**2. 地址计算的正确性：**
leaq 8(%rdi,%rax,4),%rax需要%rax为64位有符号偏移量。若i+j为负数（如-1），符号扩展后的%rax值为0xFFFFFFFFFFFFFFFF，计算地址时会正确地从基址%rdi+8向前调整偏移量（-1*4）。若未扩展，%rax将被视为0x00000000FFFFFFFF（一个极大的正数），导致无效内存访问

**==必须使用cltq：==**
1. 当 32 位有符号数（如数组索引 `i`）用于 **64 位地址计算**时
2. 如果函数返回 `int`（32 位有符号数），但调用者期望接收 64 位值（如 `long`）

# !!!数据对齐
**==浪费空间但提升性能【期末考试有一道大题会考察数据对齐】==**
**.align关键字——例如“.align 8”**

==**数据对齐原则：任何K字节的基本对象地址必须是K字节**==
	int 对应的偏移量要和4对齐（要等于4的倍数）
	对象包含结构体

**示例**：
**struct S1 {**
    **int i;**
    **char c;**
    **int j;**
**};**
![[数据对齐.png]]
### **练习3.41：体会数据对齐**
![[练习3.41.png]]
![[3.41补充.png|450]]
![[Answer.png|450]]
**==数据对齐考点：==**
1. ==**计算某个字段的偏移量——单个数据的对齐**==
	**偏移量是字段首地址**
2. ==**计算总共需要多少字节——整个结构体的对齐**==
	除了每个元素满足对齐要求，结构体末尾也要对齐（满足结构体数组），**末尾的偏移量按照最大元素对齐**

### **练习题3.45**
![[练习题3.45.png]]

1. **字节偏移量：**

![[偏移量.png]]
2. **字节总大小 ：56**

**==最小化数据对齐浪费的空间：类型字节大的放在前（依然要考虑整体的对齐）==**