# 2.1 信息存储

## 进制转换

**十进制 <-> 二进制**
**十六/八进制 <-> 二进制**

## 数据大小

| C Data Type  | Typical 32-bit | Typical 64-bit | x86-64 |
| ------------ | -------------- | -------------- | ------ |
| **char**     | 1              | 1              | 1      |
| **short**    | 2              | 2              | 2      |
| **int**      | 4              | 4              | 4      |
| **==long==** | **4**          | **8**          | 8      |
| **float**    | 4              | 4              | 4      |
| **double**   | 8              | 8              | 8      |
| **==指针==**  | **4**          | **8**          | 8      |

## 大端/小端（常考）

大端法：**最高有效位在低地址处（随地址增加顺序存储）**
**==小端法：最低有效位在低地址处——x86-64所使用的，绝大多数PC电脑==**

![[Pasted image 20250307194929.png|725]]

==**注意：字节内部是顺序的**==

## 位级运算

**& 与**
**| 或**
**~ 非**
**^ 异或 `x ^ y= (x&~y)|(~x&y)`**

## 逻辑运算

**<font color="#ff0000">非0即1</font>**
**&& 与**
**||  或**
**！非**

## 算数移位  /  逻辑移位

**算术右移（有符号数)** 和**逻辑右移（无符号数）**
**==为了维持符号，算术右移以及位数拓展都是保持最高有效位==**

# 2.2 整数表示

==**两种方式：无符号数（unsigned) / 有符号数(补码)**==
**一种只能表示非负数，另一种能够表示负数、零和正数**

**经典考点：一个w位的数字大小范围 (char w=8)**

- 无符号数： $0$ ~ $2^w-1$  **(0~255)**
- 有符号： $-2^{w-1}$ ~ $2^{w-1}-1$  **(-128~127)**

## 3种编码方式

1. **B Binary 二进制**
2. **U Unsigned 无符号数**
3. **T Two's complement 补码**

**==得到补码==** : 原码 (符号位不变，其他按位取反) -> 反码 (加1) -> 补码
### **重点： B U T 之间的相互转换**

1. **无符号数**的最高有效位是 **正权重**
2. **补码**的最高有效位是 **负权重**
3. **U和T具有相同的位模式**

- 正数：U和T可以同时表示
- 负数：U和T之间相差正负权重
![[U2T.png|625]]

### **考点1：表达式求值**

在一条表达式中既有无符号数又有有符号数,  
则**有符号数隐式转换为无符号数**

**例子：判定C语言表达式 -2147484647 -1U < 2147484647**
>[!quote]+ 答案
>
>1. int类型的最小值是 **-2147483648**
>2. -2147484647 超过int类型表示范围，被隐式转换为long类型
>3. `1U` 是 `unsigned int`
>4. `long` 的等级高于 `unsigned int`，因此 `1U` 被转换为 `long`
>5. 结果就是 **`-2147484648 < 2147484647`**

![[Unsigned and signed.png|550]]

### **考点2：特殊值**

**Tmax** = 0111 1111（0x7FFFF...）
**Tmin**  = 1000  0000 (0x80000...)
**Umax** = 1111 1111  (0xFFFFF...)
**Umin**  = 0000 0000  (0x00000...)

### **易错点：赋值隐式转换**

**注意**：C语言中当一种类型的表达式被赋值给另外一种类型的变量时，**转换是隐式的**

``` c
int tx,ty;
unsigned int ux,uy;

tx=ux; // ux Cast to signed
uy=ty; // ty Cast to unsighed
```

short  sx -> unsigned uy : **先改变大小，再完成有符号到无符号的转换**
`uy = (unsigned) (int) sx`  
 0xFFFF -> 0xFFFFFFFF -> Umax

## 位数拓展

==**符号拓展保留最高有效位——不改变符号**==
**1100 --> [1111]1100**

## 位数截断

**取模运算：截断二进制位**
`10 (01010) mod 16 = 1010  = -6`
`-10 (10110) mod 16 = 0110 =  6`

**快速：无符号数和补码具有相同的位模式**
 补码截断：**先转换成无符号数截断，再转换为补码**
 `10U mod 16 = 10U =-6`
 `-10U mod 16 = 22U mod 16 = 6U =6`

# 2.3 整数运算

## 溢出

### 无符号数

**溢出后从零开始**
 **判断**：如果溢出，必定小于两个操作数
 (unsigned char) 256=0
$$
\mathbf{x}+_w^u\mathbf{y}=\left\{\begin{array}{ll}x+y,&x+y<2^w\\\\x+y-2^w,&2^w\leq x+y<2^{w+1}\end{array}\right.
$$

### **补码**

正数+正数=负数 **正溢出**
负数+负数=正数 **负溢出**

**特殊情况：-Tmin = Tmin  (128 == -128)**
$$
\mathbf{x}+_w^t\mathbf{y}=\left\{\begin{array}{ll}
x+y-2^w,&2^{w-1}\leq x+y\quad\text{Positive overflow}\\\\
x+y,&-2^{w-1}\leq x+y<2^{w-1}\\\\
x+y+2^w,&x+y<-2^{w-1}\quad\text{ Negative overflow}\end{array}\right.
$$

## 乘法

### 变量相乘

**无符号数**：$(x\cdot y)\mathrm{~mod~}2^w$
**补码**：**先转成无符号数做乘法，再转回补码** $U2T_w((x\cdot y)\mathrm{~mod~}2^w)$
![[补码乘法例子.png|550]]

### **乘以常数**

**将常数转化为 2的幂 相加**
$$
\begin{aligned}&14=2^{3}+2^{2}+2^{1}\\&x\cdot14\:=\:x\cdot(\:2^{3}+2^{2}+2^{1})\\&=(\:x<<3\:)+(\:x<<2\:)+(\:x<<1\:)\\&x\cdot14\:=\:x\cdot(\:2^{4}-2^{1})\\&=(\:x<<4\:)-(\:x<<1\:)\end{aligned}
$$
## 除法
**除法等价于右移** : `u >> k` 等价于  `u / 2k`
- **无符号数：逻辑右移**
- **补码：算术右移**
### **特殊情况： 负数补码除法**
加入**偏置量**：$2^w-1$，再进行算术右移
	解决默认向下舍入误差

# 2.4 浮点数

**IEEE浮点数表示**

## 数值格式

| 数值形式: | $(–1)^s$ ×M×$2^E$ |     |
| ----- | ----------------- | --- |
**符号位S**：决定正负  **0/1**
**尾数M：二进制小数**
**阶码E**：是对浮点数加权
$15213_{10}=(-1)^0×1.1101101101101_2×2^{13}$

## 编码格式

![[浮点数编码 1.png]]

- **s**：一位单独的符号位直接写入
- **无符号数exp**：编码E（但不等于E）
- **frac**：字段编码尾数M（但不等于M）
**==单精度 Float ： 1 8 23==**
**==双精度 Double： 1 11 52==**

## 不同情况

### **1.规格化**

**正常的浮点数： exp字段不全为1且不全为0**

**编码方式：**

1. **exp=E+Bias**  **Bias=$2^{w-1}-1$**
 <font color="#ff0000">Float:127,Double:1023</font>
2. **尾数 M=1+f**：f是小数字段frac
 通过规格化少存储一位，提高精度

### **2.非规格化**

**表示数值0和非常接近于0.0的数**

1. ==**exp=全0**==
2. ==**M=f**==
3. ==**E=1-bias**==

### **3.特殊值**

**表示无穷或NaN**

1. **==exp全1==**
2. **==frac=0，表示无穷，s=0正无穷，s=1负无穷==**
3. **==frac!=0，表示NaN==**
## 格式考点

### **1.数值形式和编码形式的相互转换**

**单精度Float: 0xC0A00000**
↓
二进制表示：**1** **==10000001==** **010 0000 0000 0000 0000 0000**
↓
↓分离每一个部分(s | exp | frac)
↓
**S=1 负数**
**exp=128+1=129 -> E=exp-127=2**
**M= ==1.==0100000...=1.25**
↓
**V=$-1.25*2^2=-5$**

### **2.特殊值的浮点数格式**

1. **数值0**：全零(+0/-0)
2. **最小正数**：**非规格化 ->** **0** **00000000** **00...1**
	**最小非规格化(负数越大越好)** -> 1 00000000 1111...
3. **最大非规格化**： 0 00000000 1111..
4. **最小规格化数**： 0 00000001 0000...
5. **数值1**：exp等于偏移量 0 01111111 000000 = $1.0 × 2^{127-127}=1$
6. **最大规格化数**：0 **11111110** 111...1 (注意：规格化exp不能全1)
7. **无穷大**： 0 11111111 000...
8. **NaN**: 0 11111111 0001...(不全为0)

==**易错：精确表示和不可表示**==
1. 阶码一般远超尾数，所以能表示的最大整数就是 最大规格化数
2. 尾数不足无法准确表示，0 xxxx 000(n个0)可精确表示 $2^{n+1}$
3. 如果再+1就无法表示了

==**注意：先看清楚题目问的是规格化还是非规格化**==
## 浮点数加法

**阶码对齐，尾数相加**
![[浮点数加法例子.png]]

**加法会导致尾部必须舍去几位**
	**规格化有1.xxx + 1.xxx = 10.xxx(阶码相同时)**
## 浮点数乘法

**阶码相乘，尾数相加**
![[浮点数乘法.png|1375]]
## 浮点数舍入
IEEE规定了四种舍入方式，分别为：**向0舍入、向下舍入、向上舍入以及向偶数舍入**
**浮点数默认：偶数舍入**
- 若精确值在**两个可表示的浮点数中间**，选择**尾数最低位为0的选项**
- 否则选择**距离更近**的浮点数
### **例子**
​​舍入1位小数——对应的中间值为xx.**x100**,**偶数舍入结果是保持x为0**
10.0**10** ——10.00
10.1**10**——11.00
10.011——10.10 偏大
11.001——11.00 偏小

### **考点**
当小数位数超过尾数时，对尾数进行偶数舍入
	e.g. **M有3位**，1.**000**10 × $2^5$
	**舍入结果 1.000**
