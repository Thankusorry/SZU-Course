==**两种方式：无符号数（unsigned) / 有符号数(补码)**==
**一种只能表示非负数，另一种能够表示负数、零和正数**

**经典：一个w位的数字大小范围**
- Unsigned： $0$ ~ $2^w-1$
- Normal（有符号）： $-2^w$ ~ $2^w-1$

## 3种编码方式
1. **B Binary 二进制** **——原码**
2. **U Unsigned 无符号数** 
3. **T Two's complement 补码**

### **1.B2U/U2B**
无符号位，按**正权重**累加
![[B2U.png|775]]
### **2.B2T/T2B**
**==原码 取反->反码 +1->补码==**
- **Q1:为什么需要反码呢？**
- A:**解决<font color="#ff0000">“正负相加等于0”</font>的问题**
  *只有原码的情况下, 1+(-1)本应=0，但计算机算出来的却是0001+1001=1010(-2)*
- **Q2:为什么还需要补码呢？**
- A:**解决<font color="#ff0000">“0有两种表达方式”</font>的问题**
  即便有反码的情况下, 仍然有 **+0和-0两个零存在**

$$
B2T_w(\vec{x})\dot{=}-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i
$$
**最高位为==负权重==以表示负数**

| Unsigned | B    | 反码   | 补码   | T   |
| -------- | ---- | ---- | ---- | --- |
| 正数       | 0000 | 0000 | 0000 | 0   |
| 8        | 1000 | 1111 | 0000 | 0   |
| 9        | 1001 | 1110 | 1111 | -1  |
| 10       | 1010 | 1101 | 1110 | -2  |
| 11       | 1011 | 1100 | 1101 | -3  |
| 12       | 1100 | 1011 | 1100 | -4  |
| 13       | 1101 | 1010 | 1011 | -5  |
| 14       | 1110 | 1001 | 1010 | -6  |
| 15       | 1111 | 1000 | 1001 | -7  |

### **3.T2U/U2T**

**规则：**<font color="#ff0000">相同位模式</font>**，函数映射关系不同**
1. **“正数”（最高符号位是0）**，补码和原码是一样的，**U和T可以同时表示**
2. **“负数” (最高符号位为1)，U和T之间相差正负权重，即 $2^w$** [模运算]


![[T2U.png|475]]
![[Pasted image 20250308130718.png|540]]
### 表达式求值
如果在一条表达式中既有无符号数又有有符号数,  
则**有符号数隐式转换为无符号数**

`-1>0U` 实际上是`2147483647>0`
>[!fail]+ fail
>1. **基本数值与类型转换**：
  >  - `0`（signed）与 `0U`（unsigned）比较时，结果相等（`=`）。
   >     
>- `-1`（signed）转换为 `unsigned` 时会变为 `4294967295`（假设为32位系统），因此 `-1 > 0U` 成立。    
   >- `2147483647` 是 `signed int` 的最大值，而 `4294967295` 是 `unsigned int` 的最大值
    >- `(unsigned)-1` 强制转换后为 `4294967295`，与 `2147483647`（signed）比较时，前者更大（`>`）。
>2. **边界值与溢出**：
    >- `-2147483647-1` 是 `signed int` 的最小值（`-2147483648`），转换为 `unsigned` 时会变为 `2147483648U`。  
    >- `(int)2147483648U` 在32位系统中会导致溢出，结果为 `-2147483648`（依赖实现定义的行为）

注意：C语言中当一种类型的表达式被赋值给另外一种类型的变量时，**转换是隐式的**
``` c
int tx,ty;
unsigned int ux,uy;

tx=ux; // ux Cast to signed
uy=ty; // ty Cast to unsighed
```
### **位数扩展**
补码扩展最高符号位——**不改变数值大小和符号正负**
![[Pasted image 20250308201358.png]]
### **位数截断**
无符号数 :`x’=x mod`$2^k$
**重点是有符号数：**
截断补码数值就是：==先把它作为无符号数截断，再把它转换成有符号数==
*相同位模式嘛，无符号好搞就先换成无符号*
![[Pasted image 20250308202633.png]]

不改变符号：等价于**符号扩展再截断——无变化**
改变符号：
![[Pasted image 20250308202951.png]]
 