# 二进制小数
$110.11_2=  4 + 1 + 1/2  + 1/4$  
## 限制
1. 只能精确地表示形式为 x/2k的数
2. 位数固定w必会导致**下限确定，有限的数字范围**

# IEEE浮点表示
| 数值形式: | $(–1)^s$ ×M×$2^E$ |     |
| ----- | ----------------- | --- |
**符号位S**：决定数字是负数还是正数 **0/1**
**规格化数**的范围是 [1.0,2.0) M=1.xxxx
**阶码E**的作用是对浮点数加权
## 编码格式
**S**：符号位直接填入
**exp**：编码E（但不等于E）
**frac**：编码尾数M（但不等于M）
![[浮点数编码 1.png]]

**单精度 ： 1 8 23**
**双精度 ： 1 11 52**

<span style="background:#fdbfff">Q:为什么要把阶码放在前面，尾数放在后面</span>
A: 谁先出现1，谁更大，阶码决定了浮点数的范围
## 不同情况
### **1.规格化 Normal**
**exp字段不全为0且不全为1**
阶码 **exp=E+Bias** 
	<font color="#ff0000">Float:127,Double:1023</font>
**Bias=$2^n-1$** 
>[!REF]+ Reference
>实际数值和原码表示相同，所以最小值是$2^n-1$ 

**尾数 M=1+f**：f是小数字段frac
	通过规格化少存储一位，提高精度
### **2.非规格化**
**exp全为0**
**<font color="#ff0000">E=1-bias</font>**
<font color="#ff0000">M=f</font>
用途：
1. 提供了一种表示0的方法
	-  +0.0 -0.0
2. 表示那些非常接近于0.0的数值

### **3.特殊值**
**1.exp字段全为1**
**2.**
1. **frac=0，表示无穷**
2. **frac!=0, 表示NaN**
![[三种格式.png]]
### **例子：1.浮点数转十进制**
float: **0xC0A00000**
↓
二进制表示：**1** **10000001** **010 0000 0000 0000 0000 0000**
**e=128+1=129 -> E=e-127=2**
**S=1 负数**
**M=1.010 0000 0000 0000 0000 0000=1.25**
↓
**V=$-1.25*2^2=-5$**

### **2.程序看浮点数编码**
```c
double d;
void p1(){
	d=1.0;
}

int x=200;
int main(){ 
    int d=100;
    p1( );
    printf (“d=%d, x=%d\n”, d, x );
    return 0;
}
```

**为什么最后输出是 d=0,x=1072693248**

>[!note]+ **Answer**
> ![[Init.png|400]]
> p1()把d转换为$double d=1.0*2^0$,直接占了8B,
> 二进制表示为0 011111111111 000...000 
> 第二点是小端法（大部分PC电脑），因此
> ![[结果.png]]

### **3.8位浮点数串联起所有格式**
符号位s:1 阶码4位，尾数3位
对应偏置量 $2^3-1=7$ 
**非规格化：** E=1-bias=-6 
![[非规格化.png]]
**规格化：** E=e-bias
![[规格化.png]]
**特殊值：** exp全1
![[无穷大.png]]

可以双案到最大非规格化数7/512和最小规格化数8/512之间的**平滑转变。这种平滑性归功于我们对非规格化数的E的定义。**
通过将E定义为1一Bias,而不是一Bias,我们可以**补偿非规格化数的尾数没有隐含的开头的1。**

**特殊形式：**
![[不同类型的边缘.png]]

## 练习：
### **1.什么数不能用浮点数精确表示**
![[练习题2.49.png]]
分析：
1.尾数M：n位小数表示只要有效数字位数v小于等于n，那么n位尾数一定可以表示该正整数
2.阶码E：**正整数的浮点数一定都是规范化的** ，如果e超过k位二进制编码的表示范围，那么说明k位阶码无法表示该正整数
因此，不限制阶码的情况下，最小无法表示的正整数则需要n+1位尾数表示

**另一个角度：最大能准确表述的整数**： 1.1111..(n个1),即 $2^{n+1}-1$
实际上是$2^{n+1}$：因为0可以通过阶码进一步表示 10(n个0)0

所以答案是 $2^{n+1} +1$

## 舍入 Round-off
IEEE规定了四种舍入方式，分别为：**向0舍入、向下舍入、向上舍入以及向偶数舍入**

**精度：int == long>double>float**
**范围：double >float>long>int**

<font color="#ff0000">范围缩小会溢出，精度缺失会舍入</font>

需要练习： **二进制的舍入方式**
**<font color="#ff0000">首先要确定当前数值是否为中间值</font>**

### **偶数舍入 round-to-nearest**
舍入1位小数——对应的中间值为xx.**x100**
10.010 ——10.00
10.011——10.10
10.110——11.00
11.001——11.00