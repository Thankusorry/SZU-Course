## 进制转换
### **特殊的二进制转十六进制**
$2^n$ → **1000...(n个0)** → **n=i+4j**→$2^i$ **000(j个零) H** 
![[27a6b90732aa17dcfc26996b2f0324f.jpg]]
## **内存**
### **虚拟地址空间(address)**
大部分计算机**按字节寻址**，作为 **<font color="#ff0000">最小的可寻址的内存单位</font>**
**字长：** CPU一次性能处理的大小 ——32bit,64bit **=地址长度** 
**虚拟地址空间：** 所有可能地址的集合 
**==字长决定虚拟地址空间的最大大小==** 
>[!tip]+ tip
>w位机器，虚拟地址范围是$0-2^w$, 大小=$2^w*1(byte)$

![[baf9c093fdcc74a7366565cb448be2e.jpg|825]]
#### Point and long switch
这就解释了为什么从32位到64位机器，**指针类型的大小也会跟着变**
**64 位 `long` 能直接表示更大的整数**（如内存地址），减少类型转换开销

| C Data Type | Typical 32-bit | Typical 64-bit | x86-64 |
| ----------- | -------------- | -------------- | ------ |
| char        | 1              | 1              | 1      |
| short       | 2              | 2              | 2      |
| int         | 4              | 4              | 4      |
| long        | 4              | 8              | 8      |
| float       | 4              | 4              | 4      |
| double      | 8              | 8              | 8      |
| long double | −              | −              | 10/16/ |
| **pointer** | **4**          | **8**          | **8**  |

### 寻址和字节顺序
**以数据的第一个字节为地址**
字节顺序分为**大端法和小端法**
>[!note]+ note
> 在[[1.计算机系统漫游]]中得知当程序分配内存时，**起始地址是一个较小的值**，后续地址逐渐增大

大端法：**最高有效位在低地址处**
**==小端法：最低有效位在低地址处——x86-64所使用的，绝大多数PC电脑==**

![[Pasted image 20250307194929.png|725]]
>[!danger]+ 注意
> 按字节存储，所以字节内部是顺序的

### **整数和浮点数**
12345 and 12345.0
![[Pasted image 20250307200109.png|625]]
整数除了最高有效位，其他都嵌在浮点数中，是否是巧合呢？

**后续见分晓**

## **布尔代数**
![[Pasted image 20250307212456.png|172]]
### **C语言中的位级运算**
**&/AND 与** 
**|/OR 或** 
**~/NOT 非**
**^/EXCLUSIVE-OR 异或**

##### **重要应用：掩码**
得到某些位: `x & 0x00FF`
设置某些位为1： `x|0x00ff`
**设置某些位为0** : `x& 0xff00`
异或的作用： 
`x^ 0xffff` ——**异或全1**,0变1,1变0
`x^ ox0000` ——**异或全0**, 1还是1,0还是0
>[!tip]+ 好处
> **如果只想取反某一部分（异或1），保留某一部分（异或0）**
> e.g. x ^ ~0xFF == 保留最低有效位，其他取补

##### **PRACTICE**
**练习题2.13** 从20世纪70年代末到80年代末，Digital Equipment的VAX计算机是一种非常流行的机型。它**没有布尔运算AND和OR指令**，**只有bis(位设置)和bic(位清除)这两种指令**。两种指令的输入都是一个**数据字x**和一个**掩码字m**。它们**生成一个结果z**
==z = 掩码m的位 + 修改×的位==
**使用bis指令，这种修改就是在m为1的每个位置上，将z对应的位设置为1**
**使用bic指令，这种修改就是在m为1的每个位置，将z对应的位设置为0。**
为了看清楚这些运算与C语言位级运算的关系，假设我们有两个函数bis和bic来实现位设置和位清除操作。**只想用这两个函数，而不使用任何其他C语言运算，来实现按位和运算**。填写下列代码中缺失的代码。
提示：写出bis和bic运算的C语言表达式。
![[练习题代码.png]]
>[!quote]+ Answer
> bis=x|m 
> bic=x&~m                                
>  **异或定义** x ^ y= (x&~y)|(~x&y) 




### **C语言中的逻辑运算**
**<font color="#ff0000">非0即1</font>**
**|| OR**
**&& AND**
**！NOT**

### **C语言中的移位运算**
注意特殊的右移有**算术右移（有符号数)** 和**逻辑右移（无符号数）**
**==为了维持符号，算术右移以及位数拓展都是保持最高有效位==**                         
<u>**对于无符号数，必须是逻辑右移**</u>
![[算术右移.png]]
