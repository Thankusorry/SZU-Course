关键作用：
1. 分离编译，实现模块化设计——小模块编译后重新链接到应用
2. 高效率：不仅是分开编译，更是 共享库的概念，直接调用共享库，而不需要包含整个共享库的代码

# 编译器驱动程序
一步到位的系统（gcc） 称为 complier driver [第一章复习]
gcc -o prog main.c sum.c
实际上底层调用了 预处理器-编译器-汇编器-链接器的四个阶段
cpp  -o main.i main.c 
cc1 -o main.s main.i
as -o main.o main.s
ld -o main main.o sum.o

![[IMG_0296.jpeg]]
# 静态链接

可重定位目标文件(.o) +静态链接器 =可执行目标文件 

根据可重定位目标文件，链接器需要解决两个问题
## 1.符号解析
目的：每一次符号引用都能找到其符号定义

符号定义：函数起始地址 and 变量初始化
符号引用：函数被调用 and 变量被使用或赋值

注意：符号是函数 or 全局变量 or 静态变量 ，局部变量不是符号
- 局部变量分配在栈中，不会在过程外被引用，因此不是符号定义
危险：区分static和extern
- extern表示引用一个外部全局变量，因此它属于符号引用
- static表示声明一个静态全局变量，因此属于符号定义
## 2.重定位
编译器和汇编器生成的是 地址0开始的代码和数据节
链接器 将 符号定义 和 一个内存位置 关联 重定位这些节

可重定位就是将代码合并成一个文件后 原来的函数调用和变量引用仍然能保持原来的目标
# 三类目标文件
Linux系统使用ELF格式 Executable and Linkable Format
1.可重定位目标文件(.o)：二进制代码 +数据 ——可和其他可重定位文件合并为可执行文件
- 每个.o 文件由对应的.c文件生成
- 每个.o文件代码和数据地址都从0开始
2.可执行目标文件 (默认为a.out)：
- 包含的代码和数据可以被直接复制到内存并被执行
- 代码和数据地址为虚拟地址空间中的地址
3.共享目标文件(.so)：特殊的可重定位目标文件
- 在装入或运行时被装入到内存并自动被链接，称为共享库文件

## 可重定位目标文件
