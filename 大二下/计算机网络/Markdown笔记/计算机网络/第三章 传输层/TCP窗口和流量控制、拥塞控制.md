# 流量控制
流量控制本质就是**一个由接收方控制发送方发送的过程**
**目的：防止接收方来不及接收字节流，而出现报文丢失现象**
**和拥塞没有任何关系，==唯一取决于接收方的窗口值==**

​**机制**：
- 接收方通过ACK报文中的 `Window Size` 字段动态通知 `rwnd`。
- 发送方根据 `rwnd` 调整发送速率
## 三个窗口
### **1.零窗口 Zero window**
TCP**接收方的缓冲区满**——接收方往发送方发送**纯ACK报文段==(数据长度=0，窗口字段=0)==**
<font color="#ff0000">告知发送方停止发送（直到接收“非零窗口”通告为止）</font>
### **2.窗口更新 Window update**
**接收方缓冲区从满状态变到有可用空间——接收方向发送方发送纯ACK报文段==(数据长度=0，窗口字段>0)==**

### **3.窗口探测 Window probe**
**==纯ACK报文段(数据长度=0, ACK=1的报文段)不被TCP可靠递送==**
**发送方**使用==**坚持定时器(persist timer)**== 来定期触发
具体原因和背景：[[四个定时器]]
#### **具体实现**
1. **发送方往接收方**发送**窗口探测报文段(==数据长度>0==, 保证被TCP递送)**
2. 接收方返回确认报文，包含**缓冲区可用空间大小（Win)** 放入ACK报文段的窗口字段

# 拥塞控制 Congestion Control

- ​**目标**：通过 `cwnd` 防止发送方淹没网络。
- ​**机制**：
    - 慢启动（Slow Start）、拥塞避免（Congestion Avoidance）、快速重传（Fast Retransmit）等算法动态调整 `cwnd`。
    - `cwnd` 的调整基于网络拥塞信号（如丢包、延迟）
## 拥塞判定
1. ==**重传定时器超时**==——**从 慢开始 开始**
2. ==**收到三个相同（重复）的 ACK==**——**从 拥塞避免 开始**
<font color="#00b050">只要发生拥塞，SST必减半</font>
## ！三个窗口
1. **==发送窗口：Min（通知窗口，拥塞窗口 ）==**
2. **==通知窗口 rwnd==**:<font color="#ff0000">接收方</font>允许接收的能力，<u>来自接收方流量控制</u>
3. **==拥塞窗口cwnd==**：<font color="#ff0000">发送方</font>根据网络拥塞情况得出的窗口值，<u>来自发送方的流量控制</u>

## 拥塞控制过程
### **1.慢开始**
起始cwnd很小，**初始值通常为1个MSS**（单位可以设置成KB/B)
**每结束一个RTT，cwnd翻倍(指数级增加)**

**==SST:慢开始阙值和拥塞避免阶段的分界线==**

==**慢开始最后一轮cwnd一定会等于SST**==
	**慢开始最后一轮不一定是呈指数级增加-> 取决于SST**

### **2.拥塞避免阶段**
**每增加一个RTT，cwnd++（线性增加）**
**直到发生拥塞（拥塞判定为真）**

### **3.快恢复阶段**
**==将cwnd减半，直接进入拥塞避免阶段==**
	**细节：减半不算一个轮次**
**==SST和cwnd都变成发生拥塞的cwnd一半==**

**"快"相较于重新从"慢开始"开始**
#### **执行快重传算法**
![[快重传.png|475]]
- **三个重复确认不包括第一次的确认M2(必需的正常确认)**
- **==快==** 体现在==**重传定时器结束之前**==，==**第三次受到重复确认报文的时刻**==重传

>[!danger]+ Q:TCP到底采用快恢复还是慢启动？
> A:1.题目明确说明 2. 如果说明了==**三次重复确认报文/快重传——快恢复**==


# 易错点
**拥塞窗口**是接收端根据网络拥塞情况确定的窗口值
- **发送端**
假设TCP的拥塞窗口被设置为18KB，并且出现了一个**超时**。如果接下来的4次传输轮次全部成功的话，则接收窗口为（  ）（假设最大数据段长度为1KB）
- 9
- **==超时从MSS慢开始，最后到新的减半SST==** 
- ==**减半是拥塞的那一个轮次完成的，不会占一个轮次**== 1->**2->4->8->9**
有一条TCP连接，**它的最大报文段长度为2KB**，TCP拥塞窗口为24KB，这时候发生了**超时**事件，那么该拥塞窗口变成了（    ）。
- 2


### **大题**
主机甲和主机乙新建一个TCP连接，**甲的拥塞控制初始阈值是32KB**，

**甲向乙始终以MSS = 1KB大小的段发送数据，并一直有数据发送**。乙为该连接分配

**16KB 接收缓存**，并对每个数据段进行确认。忽略段传输延迟。若**乙接收的数据全部**

**存入缓存，不被取走**，则甲从连接建立成功时刻起，未发送超时的情况下，试写出经

过1RTT，2RTT，3RTT和4RTT后甲的发送窗口。

---
**初始参数：SST=32KB，MSS=1KB,rwnd=16KB,cwnd=1KB(慢起步)**

1. ​**第1个RTT**：
    - ​**发送数据**：1 KB（1个MSS）。
    - ​**接收方**：缓存占用1 KB，剩余rwnd = 16 - 1 = 15 KB。
    - ​**cwnd更新**：收到1个ACK，cwnd += 1 → ​**2 KB**。
    - ​**发送窗口**：min(2, 15) = ​**2 KB**。
2. ​**第2个RTT**：
    - ​**发送数据**：2 KB（2个MSS）。
    - ​**接收方**：缓存占用1 + 2 = 3 KB，剩余rwnd = 16 - 3 = 13 KB。
    - ​**cwnd更新**：收到2个ACK，cwnd += 2 → ​**4 KB**。
    - ​**发送窗口**：min(4, 13) = ​**4 KB**。
3. ​**第3个RTT**：
    - ​**发送数据**：4 KB（4个MSS）。
    - ​**接收方**：缓存占用3 + 4 = 7 KB，剩余rwnd = 16 - 7 = 9 KB。
    - ​**cwnd更新**：收到4个ACK，cwnd += 4 → ​**8 KB**。
    - ​**发送窗口**：min(8, 9) = ​**8 KB**。
4. ​**第4个RTT**：
    - ​**发送数据**：8 KB（8个MSS）。
    - ​**接收方**：缓存占用7 + 8 = 15 KB，剩余rwnd = 16 - 15 = ​**1 KB**。
    - ​**cwnd更新**：收到8个ACK，cwnd += 8 → ​**16 KB**。
    - ​**发送窗口**：min(16, 1) = ​**1 KB**​（受限于rwnd）。

>[!help]+ **为什么rwnd+cwnd的和固定为初始通知窗口缓存**
> **满足的条件：**
> **1.接收方缓存确定且==接受数据全部存入缓存，不被取走==**
> **2.未发生拥塞丢包——不会导致cwnd重置**

**普遍情况下 `cwnd + rwnd` 不固定**：  
**TCP 流量控制和拥塞控制独立运作**的体现，二者**分别保护接收方和网络**。