**==几次握手 决定了 被动接收方什么时候进入ESTABLISHED状态，即什么时候可以开始发数据==**

**比较片面：“因为三次握手才能保证双方具有接收和发送的能力。”**
## 重温三次握手
1. 主动发起方 发起连接
2. 被动接受方 确认连接并发起连接
3. 主动发起方 确认连接

## 首要原因
**==首要原因是为了防止旧的重复连接初始化造成混乱==**

**客户端连续发送多次 SYN 建立连接的报文**，在**网络拥堵**情况下：
- 一个「旧 SYN 报文」比「最新的 SYN 」 报文早到达了服务端；
- 那么此时服务端就会回一个 `SYN + ACK` 报文给客户端；
- **客户端收到后可以根据自身的上下文，判断这是一个历史连接（序列号过期或超时），那么客户端就会发送 `RST` 报文给服务端，表示中止这一次连接**
![[旧的历史连接.png]]

### 为什么 TCP 两次握手为什么无法阻止历史连接呢？

**在两次握手的情况下，==「被动发起方」没有中间状态给「主动发起方」来阻止历史连接，导致「被动发起方」可能建立一个历史连接，造成资源浪费==**

#### **两次握手**
1. 「主动发起方」 请求连接
2. **==「被动接收方」在收到 SYN 报文后，就进入 ESTABLISHED 状态，发送确认报文的同时发送数据==**
**「主动发起方」此时还没有进入 ESTABLISHED 状态**

**假设这次是历史连接**
- 「主动发起方」判断到此次连接为历史连接，那么就会回 RST 报文来断开连接
- 而「被动发起方」在第一次握手的时候就进入 ESTABLISHED 状态，所以它可以发送数据的，**但是它并不知道这个是历史连接，它只有在收到 RST 报文后，才会断开连接**
![[两次握手历史连接.png]]
**==导致「被动发起方」建立了一个历史连接，又白白发送了数据，妥妥地浪费了「被动发起方」的资源==**

**<font color="#00b050">要解决这种现象，最好就是在「被动发起方」发送数据前，也就是建立连接之前，要阻止掉历史连接，这样就不会造成资源浪费，而要实现这个功能，就需要三次握手</font>**

## 次要原因1
**_==同步双方初始序列号==_**

**序列号在 TCP 连接中占据着非常重要的作用**
- 当**客户端发送携带「初始序列号」的 SYN 报文**的时候，需要**服务端回一个 ACK 应答报文**，表示客户端的 SYN 报文已被服务端成功接收
- 当**服务端发送「初始序列号」给客户端**的时候，依然也要得到客户端的应答回应
这样一来一回，才能确保双方的初始序列号能被可靠的同步

![[三次握手和四次握手.png]]
**四次握手**其实也能够可靠的同步双方的初始化序号，但由于**第二步和第三步可以优化成一步**，所以就成了「三次握手」

**两次握手**只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收

## 次要原因2
- **问题本质**：客户端因网络问题重复发送多个SYN报文（例如**首次SYN未到达**，客户端超时重传）。
- **两次握手的风险**：服务器每收到一个SYN都会直接分配资源并进入连接状态（如分配内存、初始化序列号等）。若客户端多次重传SYN，服务器可能建立多个冗余连接，浪费资源。

# 总结
**不使用「两次握手」和「四次握手」的原因：**

- 「两次握手」：**无法防止历史连接的建立，会造成双方资源的浪费**，也无法可靠的同步双方序列号；
- 「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数