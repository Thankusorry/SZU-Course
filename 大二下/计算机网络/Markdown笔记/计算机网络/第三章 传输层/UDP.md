User Datagram Protocol 用户数据包协议

## 特点
1. ==**无连接、不可靠**==：开销低、尽力而为
2. **==面向报文==的传输层协议**：UDP 对应用层传递下来的报文，既不合并，也不拆分，而是**保留这些报文的边界**。UDP层一次向对方交付一个完整的报文
3. ==**没有拥塞控制**==：网络出现的拥塞时，UDP不会使源主机的发送速率降低，适合实时通信应用
4. ==**报头开销小**==：**只有8字节**
## 仅有的两个服务
1. **差错检验**——检验和
2. **多路复用/分解**——源端口号和目的端口号交付数据
## 适用范围
**性能**要求
**简短快捷**
**广播**
**流媒体，在线游戏**
## UDP报文格式
<center><font color="#ff0000">2 2 2 2</font></center>
![[UDP格式.png]]
![[UDP格式-1.png|525]]
- **伪首部**：**[32位源IP地址、32位目的IP地址]--来自IP首部、[8位保留字节(置0)]、8位传输层协议号(==TCP是6，UDP是17==)、16位报文长度(首部+数据) ==4 4 1 1 2==**
![[伪首部格式.png|454]]
- **端口号**：包括源端口号和目的端口号，分别表示发送方和接收方的进程端口号，各为2字节
- **==UDP总长度：报头+数据的总长度==，2字节**
- **校验和**：用于检查整个数据报（含报头）是否传输出错，可选，若无，填0

**==伪首部是临时的，不会传递到下一行，目的就是计算校验和，并不是UDP首部！==**

## UDP检验和计算（稍微了解）
**伪报头+UDP数据报**

**32bit**
**↓**
**16bit**
**16bit**
**每一行都拆成两个16bit数 (UDP报文全部），然后逐行求和，最后逐位取反** 
![[UDP检验和实例.png|450]]
# 练习
**1.通信子网**：不包括传输层 
（**通信子网的组成：路由器，链路，交换机**）
2.传输层为**进程之间**提供逻辑通信
**==3.接收端收到差错UDP/传输过程中被破坏——直接丢弃，校验码不包括纠错==** 
4.**伪首部**不会发给目的主机
**5.UDP数据报比IP数据报多提供了==端口功能==** : 端口号只出现在传输层报头，IP分组负责的是将数据从主机A传到主机B，需要主机B解封装到传输层得到端口号
**6.传输层：端到端连接 IP：点到点**
==**7.传输层是OSI第四层 √**==
8.UDP长度字段是UDP数据报的长度（UDP首部+数据），不包括伪首部长度
校验和=伪首部+UDP首部+应用层数据
**！伪首部包括IP分组报头的一部分**

**==9.UDP也会复用/分用服务，也会差错检验，但是不会保障可靠数据传输==**
10.传输层数据名称：报文段

**11.UDP报文分析**
0xF721 0045 002C E827
源端口号： 0xF721 目的端口 ： 0x 0045
UDP长度    0x002C 检验和   ： 0x E827

==**数据部分长度=UDP长度-UDP报头**== =0x002C-0x0008= 0x0024

目的端口=69<1024,目的端口是服务器,协议是TFTP

# 易错点
**如果UDP校验和计算机结果为0，则在校验和字段填充0** 
- UDP的校验和不是必需的，如果不使用校验和，那么将校验和字段设置为0，而如果校验和的计算结果恰好为0，那么将校验和置为全1
接收端收到有差错的UDP用户数据时的处理方式是
- 丢弃

# 思考题
（1）为什么要使用UDP？让用户进程直接发送原始的IP分组不就足够了吗？

（2）UDP协议要求一个UDP数据报的数据字段长度必须是16位比特的整数倍，不足补0。为什么？

（3）请查找checksum 源代码，理解checksum工作原理的细节。

## 特点思考
- UDP没有拥塞控制会导致发送方和接收方之间的高丢包率，并挤垮TCP会话
- 使用UDP的应用是可以实现可靠数据传输的，通过应用程序本身的可靠性机制，而不用受限于TCP拥塞控制机制导致的速率限制