# 基本概念
## **Web**
**==Web页面==**：由一些对象组成——HTML文件，JPG图像、Java小程序、声音文件等
**==形式==**：**一个基本的HTML文件**，基于HTML文件包含**其他对象的引用--“链接”**
链接通过==**URL统一资源定位符**==实现：**标识Web中的资源**，以便于用户查找
**`Prot:// user:psw@ www.someSchool.edu /someDept/pic.gif:port`**
**协议名  用户:口令  主机名             路径名            端口**
*用户名:口令 端口一般可以省略*
因此，**==URL=协议类型+主机名+路径及地址==**
## **HTTP**
**Web的应用层协议是HTTP(HyperText Transfer Protocol)超文本传输协议
C/S模式：由Web客户端(浏览器）和Web服务器组成** 
**HTTP：<font color="#ff0000">TCP 80，又分为HTTP 1.0 和HTTP 1.1</font>**
**<font color="#ff0000">HTTP是无状态协议(stateless protocol)：</font>服务器不会存储客户的任何信息**
- 维护状态的协议很复杂，如果服务器/客户端死机，它们的**状态信息可能不一致**，二者的信息必须是一致
- 无状态的服务器能够**支持更多的客户端**
# 工作机制
## **HTTP 1.0 非持续连接**
每个请求/响应都要**建立一次TCP连接**
——==下载多个对象需要多个TCP连接==
>[!warning]+ Warning
> 不需要重新建立HTML连接，增加一次RTT

![[Excalidraw/Drawing 2025-03-26 16.16.21.excalidraw|657]]
**==缺点：==** 
**每个对象要2个RTT** 
操作系统必须为每个TCP连接分配资源
但浏览器通常打开***并行TCP连接***，以获取引用对象
## 响应时间模型RTT
**Round-Trip Time 一个分组从客服端到服务器，再从服务器返回客户端的往返时间**
HTTP：TCP连接(1个RTT)，HTTP请求并等待响应(1个RTT)，文件传输
	2RTT+文件传输时间
>[!check]+ **TCP三次握手**
> TCP连接：客户向服务器发送1个小TCP报文段，服务器用一个小TCP报文段做出确认和响应——**RTT**
> ==**捎带确认：客户结合第三次握手向TCP连接发送一个HTTP请求报文**==
TCP确认报文是传输层：只有报头，没有数据
HTTP请求报文是应用层：可以作为TCP确认报文的数据，封装进去
二者能够合并

**计算时可以忽略第三次握手，因此客户端可以直接向服务器传输文件**
## HTTP 1.1 持续连接
![[持续连接.png|144]]
持续连接又分为**流水线和非流水线**
### **流水线**
客户端在**没有收到前一个响应时就发出新的请求**
——**所有引用（小）对象只花费一个RTT**是可能的
### **非流水线**
客户端**只有在接收到前一个响应时才能发出新的请求**
——**每个引用对象花费一个RTT**
![[流水和非流水.png|600]]
### **时延计算**
>[!example]+ **计算题**
> 【计算题】在如下条件下，请计算使用非持续方式和持续方式请求一个Web页面所需的时间：
（1）测试的RTT的平均值为150 ms，一个gif对象的平均发送时延是35 ms；
（2）一个Web页面中有10个gif图片，Web页面的基本HTML文件、HTTP请求报文、TCP握手报文大小均忽略不计；
（3）TCP三次握手的第三步中捎带一个HTTP请求；
（4）使用非流水线方式。

>[!note]+ note
> **持续链接=TCP连接+HTML建立+文件传输：**
> RTT+RTT+10(RTT+35)=12RTT+350=12×150+350=1500+650=2150ms
  **非持续链接：** 持续链接+多出文件个数×RTT（用于TCP连接）

## 报文格式
### **1.请求报文**

第一行是**请求行 Request line=方法字段+URL字段+HTTP版本字段**
	**方法字段**：GET POST HEAD PUT DELETE，**绝大多数为GET**
	**URL只需路径名**<--已建立连接，不需要协议名和主机名
	示例：***GET /somedir/page.html HTTP1.1***
后续是**报头(header line)**
	Host: www.someschool.edu **指明对象所在的主机(Web代理高速缓存所要求的)**
	Connection: close  **告诉服务器不要麻烦地使用持续连接，即要求服务器在发送完被请求的对象后就关闭这条连接**
	User-agent: Mozilla/5.0 **指明用户代理，即向服务器发送请求的浏览器的类型（Mozilla/5.0对应FireFox浏览器）**
		**作用：** 服务器可以有效地为**不同类型的用户代理**实际发送**相同对象的不同版本**，每个版本由相同的URL寻址
	`Accept-language:fr` 表示用户想得到**该对象的语言版本** fr->法语
	
#### **通用格式：**
![[HTTP请求报文.png|650]]
**Entity Body 实体体 使用Post方法时才会使用**
#### **提交表单输入**
**Post方式：** 包含在entity body中的输入被提交到服务器 
	http://www.baidu.com/s?wd=xx+yy+zzz&cl=3 参数：wd,cl 参数值：XX+YY+zzz,3
**GET方式:输入通过请求行的URL字段上载**：
	www.somesite.com/animalsearch?monkeys&banana 
##### **HTTP/1.0:** 
- GET
- POST
- HEAD:要求服务器在响应报文中不包含请求对象，**只有头部[^1]**-->**故障跟踪**
![[三种方法.png|950]]
##### **HTTP/1.1:**
- GET, POST, HEAD 
- **PUT** :将实体主体中的文件上载到URL字段规定的路径 
- **DELETE**：删除URL字段规定的文件

### **2.应答报文**

> **HTTP/1.1 200 OK**
> **Connection: close**
> **Date : Tue, 18 Aug 2015 15:44:04 GMT**
> **Server: Apache/2.2.3 (CentOS)**
> **Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT**
> **Content-length = 6821**
> **Content-Type:test/html**
> **(data data data data data data ...)**

>**HTTP/1.1 200 OK\r\n**
 **Connection close\r\n**
 **Date: Thu, 06 Aug 1998 12:00:15 GMT\r\n**
 **Server: Apache/1.3.0 (Unix)\r\n**
 **Last-Modified: Mon, 22 Jun 1998 …... \r**
 **Content-Length: 6821\r\n**
 **Content-Type: text/html\r\n**
 **\r\n**
 **\r\n**
 **data data data data data...** 
#### **三部分**
1. 1个**初始状态行**status line
2. 6个**首部行** header line
3. **实体体** entity body: **报文的主要部分**
##### **状态行**
==**协议版本字段+状态码+响应状态信息**==
**需要记住的常见状态码：**
- **200 OK ：请求成功**
- **202 Accepted：请求被接受，但没有马上起作用**
- **404 Not found: 文档未发现**
##### **首部行**
0. Connection
1. **Date**：首部行指示服务器 **产生并发送该响应报文的日期和时间**
	 - 具体为发送该响应报文的时间
2. **Server**：类似于请求报文的User-agent
3. **Last-modified**:**对象最后修改的日期和时间**
	- **Web缓存**
4. **Content-Length**: 被发送对象中的字节数
5. **Content-Type**：实体体中的对象类型
	- **对象类型有Content-Type正式指示，而不是文件拓展名**
##### **实体体**
包含了所请求的**对象本身 Data**
## **用户-服务器状态 cookies**
cookies能把HTTP从无状态协议变成**有状态协议**
### **四个部分组成：**
1. **<font color="#ff0000">首次</font>HTTP响应报文**中包含一个cookie的首部行
2. **之后的HTTP请求报文**中包含一个cookie的首部行
3. **<font color="#ff0000">用户端系统</font>中保留一个cookie文件**，由浏览器管理
4. **<font color="#ff0000">Web站点</font>** 有一个**后端数据库**
一句话就是：当**最初的HTTP请求**到达服务器时，该**Web站点产生一个唯一的ID**，并以此作为索引在它的后端数据库中产生一个项,后**续HTTP请求通过携带状态信息维持状态**
![[Cookies 维护状态.png]]
### **作用:**
1. **用户验证，登录账号密码**
2. **购物车**
3. 推荐
4. 用户状态 (Web email)
>[!warning]+ **Cookies与隐私**
> **Cookies允许站点知道许多关于用户的信息,可能将它知道的东西卖给第三方**
> 使用重定向和cookie的搜索引擎还能知道用户更多的信息(如通过某个用户在大量站点上的行为，了解其个人浏览方式的大致模式)
> 广告公司从站点获得信息

## Web cache--代理服务器
**目标：** 不访问原始服务器，就满足客户的请求
### **实现方式：**
用户设置浏览器：**通过缓存访问Web**
↓
**浏览器将所有HTTP请求发给缓存**
- 在缓存中的对象：直接返回 **【缓存充当服务器】**
- 不在缓存：缓存请求服务器，然后再返回给客户端 **【缓存充当客服端】**
![[缓存.png|346]]
**缓存既是客户端，也是服务器，==好处：==**
- 降低客户端请求响应时间
- 大大减少了内部网络接入互联网的带宽，降低源服务器的压力
### **示例**
**平均对象大小= 100kb** 
**机构内浏览器对原始服务器的平均请求率为= 15请求/s** 
- **平均到浏览器的速率：1.5Mbps** <font color="#ff0000">——网络的1M=1000k</font>
机构内部**路由器到原始服务器再返回到路由器的的延时**（RTT）= 2s 
**接入链路带宽：1.54Mbps**  *t=L/R=100/1540=64ms*
![[缓存示例.png]]
==**用户的请求发出到收到应答需要的时间？**==
**LAN的流量强度= 15%** 
**接入链路上的流量强度= 1.5/1.54=99%** **<font color="#ff0000">趋于无穷大</font>** 
**总延时= LAN延时+ 接入延时+ Internet 延时 = ms + <font color="#ff0000">分</font> + 2s**

#### **解决方法一：提高链路带宽**
**增加十倍带宽——成本高**
**接入链路上的流量强度= 1.5/154=0.99%** 
**总延时=ms+ms+2s** 
#### **解决方法二：安装本地缓存**
**代价:web缓存(廉价!)**
![[Local Web cache 1.png|462]]

**假设缓存命中率0.4**：40%请求在缓存中被满足，其他60%的请求需要被原始服务器满足 
**接入链路利用率**: 60%的请求采用接入链路进过接入链路到达浏览器的数据率= 0.6 * 1.50 Mbps =0.9 Mbps 
	**利用率= 0.9/1.54 =0.58** 
**总体延迟** = **0.6 * (从原始服务器获取对象的延迟) +0.4 * (从缓存获取对象的延迟)** 
	**从原始服务器获取对象的延迟=ms+2s+$\frac{I}{1-I}{\frac{L}{R}}$** 
= **(2.01 * 0.6)** + 0.4 (**ms**) = ~ 1.2 secs 
	**<font color="#ff0000">比安装154Mbps链路还来得小(而且比较便宜!)</font>**

### **Last-Modified**
**缓存器:** 在HTTP请求中指定缓存拷贝的日期 `If-modified-since`:
**服务器:** 
如果缓存器中的对象拷贝是**最新的**，就**不要发送对象**
如果缓存拷贝**陈旧**，则响应报文**没包含对象**
**==保证缓存和服务器保持一致==**
![[Web缓存 1.png|500]]
# Practice
如果传输的请求与应答报文丢失，将由Web浏览器与Web服务器组织重传？
>[!note]+ Answer
> **重传是TCP做的事情，浏览器是应用层，应当由客户机和服务器进行重传**



[^1]: HTML包含head 和body

