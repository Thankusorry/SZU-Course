## 1.TCP建立连接
服务器根据端口号 12345 创建 Serversocket

**三次握手:**
1. 客户端根据服务器IP+端口号创建socket，请求连接
	 向服务器发送 ​**SYN** 包，等待 ​**SYN-ACK** 并回复 ​**ACK**。
2. 服务器接收客户端的连接请求
	 **Socket clientSocket = serverSocket.accept();**
3. 客户端确认连接

## 2.指令交互
**演示**
## 3.1文件传输
服务器先发送文件名
客户端收到文件名，确认是否是这个文件
服务器得到确认后，才开始传输
客户端收到文件可以自行重命名和存放位置

**增加一条指令：dir 可以输出服务端存储的文件列表**
## 3.2实现任意文件传输
### **实现原理**

1. ​**二进制传输机制**  
    所有文件在底层均以二进制形式存储。代码通过以下步骤实现无关格式传输：
    
    - ​**服务器端**：将文件内容读取为 `byte[]`（如 `Files.readAllBytes`）。
    - ​**网络传输**：通过 `DataOutputStream.write(byte[])` 直接发送二进制流。
    - ​**客户端**：接收完整的 `byte[]` 并直接写入本地文件，​**不修改文件内容**。
2. ​**无格式限制的关键**
    - 代码不解析文件内容，仅传递原始字节，因此**不受文件类型限制**。
    - 文件类型标识（如 `.mp3`）由扩展名决定，而扩展名在传输过程中被保留。

## 4. 解决网络数据大小端问题
大小端是两种数据存储方式
根据网络传输规范，传输统一用大端模式
但是操作系统大部分x86都是使用小端存储
**所以需要将传输的大端数据变回小端**
### **解决措施**
使用Java的标准库 `DataInputStream`和`DataOutputStream`
**DataOutputStream 底层强制使用大端模式**
	​**写入时**：所有多字节数据（`int`、`long`、`short` 等）都会被拆分为大端模式的字节序列
**DataInputStream读取会自动将大端数据转换回本地的小端数据**
## 5.拓展功能1：增加数据库
### **实现原理：**
**增加了一个静态数据库的类，用于随机生成和存储 100个学号-姓名-性别**
**服务器收到命令就在数据库里面查询**
**客户端接收查询结果**

### **怎么解决TCP粘包问题**
**问题：客户端多次写入命令可能会被合并读取**
**服务器可能一次性读取到 `"TimeQuery 20210001"`，导致命令解析错误**

**解决方法：**
- `writeUTF()` 会在数据前写入2字节的**长度前缀**
- `readUTF()` 会根据长度前缀读取精确长度的数据
**<验证程序>**
## 6.拓展2：对实现的功能进行GUI实现
**演示**
